token = returnDescriptionInfo.token;
token  = eatTokensUntilEOL(token);
token  = eatTokensUntilEOL();
 continue retry;
token =  eatTokensUntilEOL(); continue retry;
 else { token = eatTokensUntilEOL(token;
token  = null;
token = returnDescriptionInfo.token; continue retry;
 else { token = eatTokensUntilEOL;
token  = returnDescription ;
 else { token = returnDescriptionInfo.token;
 else { token = eatTokensUntilNL(token;
 else { token = eatTokensUntilEOL(returnDescriptionInfo.token;
token  = eatTokensUntilNL();
 return token.token;
 else { token = eatTokensUntilEOL();
 else { token = eatTokensUntilEOL ( token )
 else { token = eatTokensUntilEOL(token);
 else { token = eatTokensUntilEOL.token;
 else { parser. addParserWarning ( "msg.jsdoc.incompat.type", lineno, charno); }
 else { returnDescription=returnDescriptionInfo.token;
token = returnDescriptionInfo.token; break;
 else { parser. addParserWarning ( "msg.jsdoc.incompat.type", lineno, charno);
 else { token = JsDocToken.token;
 else { parser. addParserWarning ( "msg.jsdoc.incompat.description", lineno, charno); }
 else { token = eatTokensUntilEOL(token); } else { token = eatTokensUntilEOL(token); } } else {
token =  eatTokensUntilEOL(token); break;
 else { parser. addParserWarning ( "msg.jsdoc.incompat.description", lineno, charno);
 else { parser. addParserWarning ( "msg.jsdoc.incompat.type", lineno); }
 else { token = eatTokensUntilEOL(token); } else { token = eatTokensUntilEOL(token); }
 else { parser. addParserWarning ( "msg.jsdoc.incompat.return", lineno, charno); }
 else { parser. addParserWarning ( "msg.jsdoc.incompat.type", lineno, charno); break ; }
 returnDescription=returnDescriptionInfo.token;
 else { parser. addParserWarning ( "msg.jsdoc.incompat.return", lineno, charno);
 else { token = eatTokensUntilEOL(token); } } else {
 else { token = eatTokensUntilEOL(token); } } else { token = eatTokensUntilEOL(token); }
 else { token = eatTokensUntilEOL+returnDescriptionInfo.token;
 else { token = eatTokensUntilEOL(token); } if ( returnDescriptionInfo!= null ) {
 else { token = eatTokensUntilEOF ; }
 else { token = eatTokensUntilEOL(token); } else { token = eatTokensUntilEOL(); }
 else { token = eatTokensUntilEOL(token); } else {
 else { token = eatTokensUntilEOL(token); } if ( returnDescriptionInfo. token!= null ) {
 if ( returnDescriptionInfo!= null ) {
 else { token = eatTokensUntilEOL(token); } } else { token = eatTokensUntilEOL(); }
 else if (returnDescriptionInfo.token!= null) {
 else if (returnDescriptionInfo.token) {
 else { parser. addParserWarning ( "msg.jsdoc.incompat.description" ) ; }
 else { parser. addParserWarning ( "msg.jsdoc.incompat.description", lineno); }
 else { token = eatTokensUntilEOL(token); } break ; } else {
 else { parser. addParserWarning ( "msg.jsdoc.incompat.return", lineno); }
 else { parser. addParserWarning ( "msg.jsdoc.incompat.type" ) ; }
 else { token = eatTokensUntilEndtoken;
 else { token = eatTokensUntilEOL(token); } if ( token == null ) {
 else { token = eatTokensUntilEOL(token); } break ; } } else {
 else { token = eatTokensUntilComment(token;
 else { token = eatTokensUntilNL(token);
 if (returnDescriptionInfo.token!= null) {
 } else { token = eatTokensUntilEOL;
 else { token = eatTokensUntilEOL(token); } if ( returnDescription!= null ) {
 else { token = jsDocToken.token;
 else { parser. addParserWarning ( "msg.jsdoc.incompat.type", lineno, charno); } }
 else { token = eatTokensUntilEOL(token); }
 else { token = eatTokensUntilEOF(); }
 if ( returnDescription!= null ) {
 else { token = eatTokensUntilEOL(token); } } else { token = eatTokensUntilEOL(token); } } }
 else { parser. addParserWarning ( "msg.jsdoc.incompat.type", token); }
 else { parser. addParserWarning ( "msg.jsdoc.incompat.description", lineno, charno); } }
 else { token = eatTokensUntilNL();
 else { token = eatTokensUntilEOL(token); } if ( returnDescriptionInfo!= null )
 token = token.token;
 } else { token = eatTokensUntilEOL();
 else { token = eatTokensUntilEOL();returnDescriptionInfo.token;
 else { token = eatTokensUntilEOL()returnDescriptionInfo.token;
 else { token = eatTokensUntilEOL(token); } } else { if ( returnDescription ) {
 else { token = eatTokensUntilEOL(token); } else { if ( token == null ) {
 else { token = eatTokensUntilEOL(token); } } } else {
 else { token = eatTokensUntilEOFToken;
 else { token = eatTokensUntilEOL(token); } if ( returnDescription ) {
 else { token = eatTokensUntilEOL(token); } } else { token = eatTokensUntilEOL(token); } }
 else { parser. addParserWarning ( "msg.jsdoc.incompat.description", token); }
 else if (returnDescriptionInfo.token!= null)
 else { token = eatTokensUntilEOL(token); } if ( returnDescriptionInfo. token ) {
 else { token = eatTokensUntilEOL(token); } else { token = eatTokensUntilEOL(token); } }
 else { if (returnDescriptionInfo.token) {
 else { token = eatTokensUntilEOL(); break ;
 if (returnDescriptionInfo.token!= null)
 else { parser. addParserWarning ( "msg.jsdoc.incompat.type", lineno, charno); } } }
 } else { token = eatTokensUntilNL(token;
 else { token = eatTokensUntilNL;
 else { token = eatTokensUntilEOL(token); } else { token = eatTokensUntilEOL(token); } } }
token =  eatTokensUntilEOL()); continue retry;
 if ( token == null ) {
 else { if (returnDescriptionInfo.token!= null) {
 else { token = eatTokens ( ) ;
 else { if (returnDescriptionInfo.token!= null)
 else { parser. addParserWarning ( "msg.jsdoc.incompat.description", lineno, charno); } } }
 else { parser. addParserWarning ( "msg.jsdoc.incompat.type", lineno); } }
 else { token = nextToken.token;
 else { parser. addParserWarning ( "msg.jsdoc.incompat.description", ""); }
token = returnDescriptionInfo.token; token = eatTokensUntilEOL();
 else { token = eatTokensUntilEOL(token); } break ; } } } else {
 else { if ( token == null ) {
 else { token = eatTokensUntilEOL(token); } else { token = eatTokensUntilEOL(); } }
 else if (returnDescriptionInfo.token!== null) {
 else { token = eatTokensUntilEOF(token;
 if (returnDescriptionInfo.token) {
 else { if (returnDescriptionInfo!= null)
token  = eatTokensUntilEOL(token); }
 else { token = null ; break ;
 else { token = eatTokensUntilReturnDescriptionInfo.token;
 if ( token == null ) { break ;
 break; } else { token = eatTokensUntilEOL(token); }
 else { token = eatTokensUntilEOL(); } else {
 else { token = eatTokensUntilEOL(); } } else {
 else { if ( returnDescription!= null ) {
token  = eatTokensUntilComment();
 } else { token = eatTokensUntilEOL.token;
 else { token = eatTokensUntilEOL().returnDescriptionInfo.token;
 } else { token = JsDocToken.token;
token  ++ ;
 else { token = eatTokensUntilEOL(); continue retry; }
 else { token = returnDescription ;
 else if (returnDescriptionInfo!= null)
 else { token = '\n'+returnDescriptionInfo.token;
 else { token = eatTokensUntilNL(returnDescriptionInfo.token;
 else { parser. addParserWarning ( "msg.jsdoc.incompat.description", lineno); } }
 if ( returnDescriptionInfo ) {
 else { token = eatTokensUntilEOL(); }
token  = eatTokensUntilEOL(returnDescription);
 else if ( token == null ) {
token  = eatTokensUntilComment(token);
 else { token = eatTokensUntilEOL(token); } break ; } } } }
 } else { token = returnDescriptionInfo.token;
 } continue retry;
 else { returnDescription = null ; }
 else { token = eatTokensUntilEOF.token;
 else { token = eatTokensUntilEOL(token); } continue retry; }
token  = eatTokensUntilEOL(); continue retry
 else { token = eatTokensUntilEOL+token;
 else { token = eatTokensUntilCRLF.token;
 else { token = eatTokensUntilOL(token;
 else { token = returnDescription.token;
 continue retry
token = returnDescriptionInfo.string; continue retry;
 else { token = eatTokensUntilEOFtoken;
 else { token = eatTokensUntilEOF();
 else { returnDescription = JsDocToken.token;
 } else { token = eatTokens ( );
token  = eatTokensUntilToken();
 else { token = eatTokensUntilEOL(token); } break ; } } }
 else { token = eatEOL(token;
 else { token = eatTokensUntilEOF;
 } break;
 else { token = null ; }
 else { token = eatTokensUntilEndOfLine.token;
 else { token = eatTokensUntilEnd(token;
 else { token = eatTokensUntilEOL(token); } }
token  = eatTokensUntilEOL;
 } else { token = eatTokensUntilEndtoken;
 else { token = eatTokensUntilEOL(token); } } else { token = null ; }
 else { token = eatTokensUntilEOL(token); } break ; } } } } }
 else { token = eatTokensUntil_token;
token = returnDescriptionInfo.token; continue retry
token = returnDescriptionInfo.token; } break ;
token  = eatTokensUntilEOL(); }
 else { token = eatTokensUntil(token;
 else { token = eatTokensUntilEOL(token); } } else { token = null ; } }
token = returnDescriptionInfo.token; continue retry; } break ;
 else { returnDescription = "" ;
token  = returnDescription ; }
 else { token = eatEOF(token;
 else { token = eatTokensUntilEOL(token); } } } }
token = returnDescriptionInfo.endToken;
 else { token = eatTokensUntilEOL(token); } break ; } }
 else { token = "return: "+returnDescriptionInfo.token;
 else { returnDescription = "" ; }
 else { token = null ; } }
 else { token = eatTokensUntilEOL(token); } } }
token  = eatTokensUntilOL();
 else { token = eatTokensUntilEndOfBlock.token;
 else { token = eatTokensUntilEOL (token);
 else { token = eatTokensUntilComment();
 else { returnDescription = null ;
 else { returnDescription = (String)returnDescriptionInfo.token;
token = returnDescriptionInfo.token; } continue retry ;
 else { token = eatToken ( );
 break; } else {
token = returnDescriptionInfo. string ; break ; } continue retry ;
 else { token = "return "+returnDescriptionInfo.token;
 else { token = eatTokensUntilEOOL += returnDescriptionInfo.token;
token = returnDescriptionInfo.toString(); continue retry;
 if ( token == null ) { returnDescriptionInfo = null ; }
 else { token = retDescriptionInfo.token;
 else { token = eatTokensUntilEOL(token); } } else { token = token ; }
token = returnDescriptionInfo.token; token = eatTokensUntilNL();
token = returnDescriptionInfo.nextToken;
 else { token = token.token;
token = returnDescriptionInfo.token; break; } continue retry ;
 else { token = eatTokensEOL;
 } else { token = eatTokensUntilComment(token;
 else { token = eatTokensUntilNL+returnDescriptionInfo.token;
 else { if ( returnDescription ) {
 else { token = eatTokensUntilEOL += returnDescriptionInfo.token;
 else { token = eatTokensUntilToken+returnDescriptionInfo.token;
token = returnDescriptionInfo.token; continue retry; } }
token = returnDescriptionInfo.token; token = eatTokensUntilNL(token);
 else { token = ' ' ; } token= returnDescriptionInfo.token;
 break; } else { returnDescription=returnDescriptionInfo.token;
 else { token = eatTokensUntilEOL(token); } break ; } } } else
 else { token = eatTokensUntilEOL(); continue retry; } }
 else { token = eatTokensEndLine;
 else { token = null ; } token= returnDescriptionInfo.token;
 else { token = returnDescriptionInfo;
 if ( returnDescription ) {
 else { token = eatTokensUntilEOL(); continue retry; } } }
token = returnDescriptionInfo.token; continue continue;
 else { token = ' ' ; }
 else { token = eatTokensUntilEOL(); } continue retry; }
 else { token = eatTokensUntilEOL(token); } break ; } } else { }
 else { returnDescriptionToken=returnDescriptionInfo.token;
 else { token = next_token;
token = returnDescriptionInfo.token; break; } else { token = null ;
 else { token = eatTokensUntilEOF += returnDescriptionInfo.token;
 else { token = retry.token;
 else { token = eatTokensUntilEOL(token); } break ; } else { }
token = returnDescriptionInfo. string ; continue retry ; } break ;
token  = eatTokensWhileEOL(token);
 else { token = null ; returntoken;
token = returnDescriptionInfo.token(); continue retry;
 else { token = eatTokensUntilEOL(); } }
token  = eatTokensUntilEOL(); break;
 } else { token = null ; }
 continue retry; } } break;
token  = null ; break ;
 } else { token = eatToken ( );
 continue retry; break;
 } else { token = eatTokensUntilNL;
token = returnDescriptionInfo.token; continue retry; } break ; }
token = returnDescriptionInfo ; }
 else { returnDescriptionInfo=returnDescriptionInfo.token;
 else { token = eatTokensUntilEOL(token); } break ; } } } } else
 else { token = eatTokensUntilEOL(token); } } else
 else { token = eatTokensUntilEndLine.token;
 else { token = ': ' +returnDescriptionInfo.token;
 } else { returnDescription=returnDescriptionInfo.token;
 else { returnDescription = null ; }
 else { token = null ; } returnDescription= returnDescriptionInfo.token;
 else { token = eatNext ( ).token;
token = returnDescriptionInfo. string ; break ; } break ; } }
 else { token = eatTokensUntilEOL(token); } else
 else { token = ' ' ; } returnDescription= returnDescriptionInfo.token;
 else { returnDescription [ 0 ] ^= returnDescriptionInfo.token;
 else { returnDescription.token=returnDescriptionInfo.token;
 else { token = eatTokensUntilEOL(); continue retry; } } else
 continue retry; } }
 else { token = null ; breaktoken;
 continue break;
token  = returnDescriptionInfo ;
token = returnDescriptionInfo.token; break; } continue retry
token  = consume ( ) ;
 else { token = eatTokensUntilOL(); token= returnDescriptionInfo.token;
token = returnDescriptionInfo.replace ( ' ', ' ' ) ; }
token = returnDescriptionInfo.token; break; } } }
token = returnDescriptionInfo.token; continue break;
token = returnDescriptionInfo. next ( ) ;
 break ; }
 else { token = token ; } returnDescription= returnDescriptionInfo.token;
token  = eatTokensUntilEOF
 else { token = resultDescriptionInfo.token;
token = returnDescriptionInfo.token; break; } break ;
 else { token [ "description" ]= returnDescriptionInfo.token;
 return description ; } break ;
 else { returnDescriptionInfo. returnDescription |= returnDescriptionInfo.token;
token = returnDescriptionInfo.toString(); continue retry; } break ;
 else { token = lastToken.token;
 } else {
token  = eatTokensUntilEOF(); }
 else { returnDescription = null ;
token = returnDescriptionInfo.token; continue retry; } } break ;
 break; } } }
token = returnDescriptionInfo.token; continue retry; break;
 else { token = eatTokensUntilEOL(); } } }
 else { returnDescriptionInfo=token;
 else { token = "returnDescription"= returnDescriptionInfo.token;
token  = eatTokensUntilEOF();
 else { token = null ; returnDescription= returnDescriptionInfo.token;
 else { token = eatTokensUntilEOL(); } } } }
 continue retry ; }
token  = ' ' ; }
token = returnDescriptionInfo.next;
token = returnDescriptionInfo.token; break; } } continue retry ;
 } else { token = returnDescription;
token = returnDescriptionInfo.token; break; } } break ;
token = returnDescriptionInfo.nextToken();
 else { returnDescription = "" ;
token = returnDescriptionInfo.endOfLine;
 } else { token = nextToken.token;
 return returnDescription ;
 else { token = null.token;
 else { token = skipNext ( ).token;
token = returnDescriptionInfo. string ; continue retry ; } } }
 } else { returnDescriptionInfo=returnDescriptionInfo.token;
 } else { continue retry;
token = returnDescriptionInfo.token
 else { token = returnDescription=returnDescriptionInfo.token;
token = returnDescriptionInfo.toString(); break; } continue retry;
token = returnDescriptionInfo.toString(); return token ; } break ;
 break; } } break ;
 else { returnDescription = ".";
 else { returnDescription.text=returnDescriptionInfo.token;
token = returnDescriptionInfo.string;
token = returnDescriptionInfo.endLine();
 else { token = tokenInfo.token;
token = returnDescriptionInfo.toJSDocString(token); } break ;
 } returntoken;
 else {
token = returnDescriptionInfo.token; token = eatTokensUntilEOL(); }
token  = eatTokensUntilEOL; }
token = returnDescriptionInfo.endOfLine();
token = returnDescriptionInfo.token; continue retry; }
token = returnDescriptionInfo.nextToken(); continue retry; } }
 } } continue retry;
 } else { token = tokenInfo.token;
token = returnDescriptionInfo.endToken();
 else { token = - 1;
 return token = returnDescription.token;
token = returnDescriptionInfo.toString(); continue retry; } }
token = returnDescriptionInfo.token; token = eatTokensUntilEOF(); }
 else { token = null_token;
 else { returnDescription |= returnDescriptionInfo.token;
token = returnDescriptionInfo.token; token = eatTokensUntilEOOL(); }
 else { returnDescription +=returnDescriptionInfo.token;
 else { returnDescription ^= returnDescriptionInfo.token;
 else { parser.returnDescription |= returnDescriptionInfo.token;
token  = eatTokensUntilEOOL();
 else { parser.nextToken |= returnDescriptionInfo.token;
 else { returnDescription *= returnDescriptionInfo.token;
token = returnDescriptionInfo.token(); break;
 break ; } }
token  -- ;
 continue retry;
 else { } token=returnDescriptionInfo.token;
 else { parser.returnDescription ^= returnDescriptionInfo.token;
 returnDescriptionInfo.token;
 return returnDescription.token;
 continue continue;
 else { returnDescription=token;
token = returnDescriptionInfo.nextToken(); continue retry; }
 else { parser.currentToken |= returnDescriptionInfo.token;
 else { parser.returnDescription <<= returnDescriptionInfo.token;
 } else { returnDescription *= returnDescriptionInfo.token;
 } else { returnDescription |= returnDescriptionInfo.token;
token  += returnDescription;
 return retry; break;
 else { token [ 0 ]= returnDescriptionInfo.token;
 return descriptionInfo.token;
 else { parser.lastToken= returnDescriptionInfo.token;
token = returnDescriptionInfo.toString(); continue retry; }
 returnDescription = token.token;
 } else { returnDescription ^= returnDescriptionInfo.token;
 else { token =!returnDescriptionInfo.token;
 returnToken=returnDescriptionInfo.token;
 token = returnDescription.token;
token = returnDescriptionInfo.text;
 returnToken = returnDescription.token;
token  = null ; }
token = returnDescriptionInfo.end;
 else { break ; } }
 token = next.token;
 else { returnDescription ||= returnDescriptionInfo.token;
 break; } returntoken;
 break; } } } }
 returnDescriptionToken=returnDescriptionInfo.token;
 else { returnDescription.= returnDescriptionInfo.token;
 return returnDescriptionInfo.token;
 break; } break;
 else { token = nexttoken;
 return retry.token;
 returnDescription = ".";
 else { token = _token;
token  = null
 break ; } } }
 else { token = next.token;
 token = info.token;
 returnType=returnDescriptionInfo.token;
token = returnDescriptionInfo.toJSDocString(token); }
 return retry; returntoken;
 } token = token.token;
 continue retry; }
 return type = returnDescription.token;
 returnDescription=token;
token  += 1 ;
 } break retry;
 } } }
 } return returnDescription;
 retry=token;
 return type.token;
token  = "" ;
token  break ;
 return type = token.token;
 break; } else { }
token = returnDescriptionInfo. ;
token = returnDescriptionInfo.text
 } token=returnDescriptionInfo.token;
 break ; } }
 return token.next.token;
token = returnDescriptionInfo.next
 else { break token= returnDescriptionInfo.token;
 } return token.token;
 break ; }
token =  - 1 ;
 else { token |= returnDescriptionInfo.token;
 break retry;
 token=token;
 returnDescriptionInfo=token;
 } } returntoken;
 returnDescription =!returnDescriptionInfo.token;
 return info.token;
 returnDescription *= returnDescriptionInfo.token;
 retry(token;
 return null;
 returnDescription |= returnDescriptionInfo.token;
 returnDescription ^= returnDescriptionInfo.token;
 else { token ^= returnDescriptionInfo.token;
 else { } }
 else { returnToken= returnDescriptionInfo.token;
 return retry++;
 } returnreturnDescriptionInfo.token;
 returnDescription ||= returnDescriptionInfo.token;
 type=returnDescriptionInfo.token;
 return this.token;
 return retry;
 } ++token;
 else { }
 token |= returnDescriptionInfo.token;
 return node.token;
token = returnDescriptionInfo.token ; }
 } } break;
 continue loop;
token =  undefined;
 } --token;
 } }
 returnDesc= returnDescriptionInfo.token;
token =  '' ;
token = returnDescriptionInfo.tokenEnd;
 break;
 } else
token = returnDescriptionInfo.token; break
token = returnDescriptionInfo.tokenEnd();
token += returnDescriptionInfo.token;
 }
 else
token -= returnDescriptionInfo.token;
token: returnDescriptionInfo.token;
