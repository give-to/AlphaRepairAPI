tmpVec    = residuals;
 cost = 0;
 cost = cost;
 cost=residuals;
 tmpVec *= residuals;
 tmpVec [ cost ]= residuals;
 cost = cost ;
 var tmpVec = new VectorialPointValuePair ( ) ;
 gradients = [ ] ; gradients. push ( cost ) ;
 var tmpVec = new VectorialPointValuePair ( point ) ;
 cost = previousCost;
 var tmpVec = point [ cost ] ; point [ cost ] = tmpVec ; objective [ cost ] = objective [ cost ] ;
 gradients = [ ] ; gradients [ ] = gradients ;
 var tmpVec = new VectorialPointValuePair ( cost ) ;
 double
 var tmpVec = new VectorialPointValuePair ( point, objective ) ; residuals = tmpVec ;
 gradients = [ ] ; gradients. push ( ) ;
 gradients = [ ] ; gradients [ ] = gradients [ ] ;
 var tmpVec = new VectorialPointValuePair ( point, objective ) ; residuals = oldRes ;
 var tmpVec = new VectorialPointValuePair ( point, objective, costRelativeTolerance ) ;
 var tmpVec = new VectorialPointValuePair ( point, objective ) ; residuals = residuals ;
 var tmpVec = new VectorialPointValuePair ( point, objective, xNorm ) ;
 var tmpVec = new VectorialPointValuePair ( point, objective, xNorm, cost ) ;
 var tmpVec = new VectorialPointValuePair ( point, objective ) ; residuals = res ;
tmpVec     = cost ;
 var tmpVec = new VectorialPointValuePair ( point, objective ) ; var oldRes = res;
 var tmpVec = new VectorialPointValuePair ( cost, objective ) ; residuals = tmpVec ;
 var tmpVec = new VectorialPointValuePair ( point, objective ) ; residuals = 0 ;
 var tmpVec = new VectorialPointValuePair ( point, objective, residuals ) ;
 gradients = [ ] ; gradients [ 0 ] = gradients ;
 var tmpVec = point [ cost ] ; oldRes = point [ cost ] ; residuals = oldRes [ residuals ] ;
 var tmpVec = new VectorialPointValuePair ( point, objective, cost, xNorm, delta ) ;
 residuals=residuals;
 var tmpVec = new VectorialPointValuePair ( point, objective ) ; cost = cost ;
 var tmpVec = new VectorialPointValuePair ( point, objective ) ; residuals = cost ;
 var tmpVec = new VectorialPointValuePair ( point, objective ) ; objective = objective ;
 var tmpVec = new VectorialPointValuePair ( point, objective, xNorm, delta ) ;
tmpVec     = new VectorialPoint ( ) ;
 var tmpVec = new VectorialPointValue ( ) ;
 tmpVec [ cost ] *= residuals;
 var tmpVec = point [ cost ] ; var oldRes = point [ cost ] ; residuals = oldRes [ residuals ] ;
 var tmpVec = point [ cost ] ; var oldRes = point [ cost ] ; var residuals = oldRes [ cost ] ;
 var tmpVec = new VectorialPointValuePair ( point, objective ) ; var oldRes = oldRes ;
 var tmpVec = point [ cost ] ; var oldRes = point [ cost ] ; residuals = oldRes [ cost ] ;
 var tmpVec = point [ cost ] ; oldRes = point [ cost ] ; residuals = oldRes = tmpVec ;
 gradients = [ ] ; gradients [ ] = cost ;
tmpVec     = point [ cost ] ;
tmpVec     = point [ cost ] [ xNorm ] ;
 gradients = gradients ;
 gradients = gradients ; residuals = residuals ;
 var tmpVec = new VectorialPointValuePair ( point, objective ) ; objective = null ;
tmpVec     = new VectorialPointValue ( ) ;
tmpVec     [ cost ] = xNorm ;
 var tmpVec = new VectorialVector ( xNorm ) ;
 gradients = [ ] ; gradients += gradients ;
 var tmpVec = new VectorialPointValue ( point ) ;
 var tmpVec = new VectorialPointValuePair ( point, objective ) ; residuals = residuals + cost ;
 gradients = [ ] ; gradients = [ ] ;
tmpVec     = newVec ;
tmpVec     = new Vec ( cost ) ;
 cost = previousCost ;
tmpVec    = residuals [ cost ] ; residuals [ cost ] =
 gradients = [ ] ; gradients = gradients ;
 gradients = [ ] ; gradients [ ] = gradient ;
tmpVec     = new Vectorial ( ) ;
tmpVec    = residuals; } else {
 gradients = [ ] ; gradients [ ] = grad ;
 var tmpVec = new VectorialPointValuePair ( point, objective ) ; residuals = residuals + delta ;
 gradients = gradients + gradients ; gradients = gradients + gradients ;
 var tmpVec = point [ cost ] ; point [ cost ] = tmpVec ; objective [ cost ] = objective [ cost ] =
tmpVec     = new VectorialVector ( cost ) ;
tmpVec     = new Vectorial (cost);
tmpVec     = new VectorialVector ( ) ;
tmpVec     = new VectorialPoint ( point ) ;
 cost = newCost ; residuals = tmpVec ;
tmpVec    = residuals ; cost = previousCost ;
 gradients = [ ] ; gradients [ ] = gradients [ ] =
 var tmpVec = point [ cost ] ; point [ cost ] = tmpVec ; objective [ cost ] = objective ; }
tmpVec     = new VectorialPoint (cost);
 tmpVec [ xNorm ] *= residuals;
 gradients = [ ] ; gradients. push ( ) ;
 cost = cost ; residuals = residuals ;
 gradients = [ ] ; gradients. length = 0 ;
 gradients = gradients + gradients ; gradients = gradients - gradients ;
 residuals = oldresiduals;
 cost = newCost ;
tmpVec     = newRes ;
tmpVec     = new VectorialPointValue (cost);
 cost = previousCost ; residuals = tmpVec ;
 tmpVec [ cost ] [ xNorm ]= residuals;
 var tmpVec = point [ cost ] ; point [ cost ] = tmpVec ; objective [ cost ] = objective ; var
 gradients = gradients + gradients ; gradients = gradients * gradients ;
 var tmpVec = new VectorialPointValuePair(point); var
 gradients = gradients + cost ;
 gradients = gradients + xNorm ;
 gradients = [ ] ; gradients [ ] = cost ;
 xNorm = xNorm;
 var tmpVec = new VectorialPointValuePair ( point, objective, cost ) ; var
 gradients = [ ] ; gradients. push ;
tmpVec    = residuals [ cost ] [ xNorm ] ;
tmpVec     = new VectorialSolution ( ) ;
 cost = newCost ; residuals = old_residuals;
 tmpVec = cost ; cost *= residuals;
tmpVec    =  point[cost] ; point[cost] =
 tmpVec = cost ; cost= residuals;
 gradients = [ ] ; gradients [ 0 ] = gradients ; }
 cost = newCost ; residuals = newRes ;
 gradients = gradients ; residuals = residual ;
 gradients = [ ] ; gradients [ ] = gradients ; double
tmpVec    = residuals [ cost ] ; residuals = null ;
 var tmpVec = new VectorialPointValuePair ( point, objective ) ; var
tmpVec    = residuals; tmpVec. cost = cost ;
 gradients = [ ] ; gradients = cost ;
 var tmpVec = new VectorialPointValuePair(); var
 gradients = [ ] ; gradients [ 0 ] = gradients ; double
 gradients = newGradients ( ) ;
tmpVec    =  point[cost] ; this.
 gradients = gradients [ cost ] ;
 tmpVec = cost *= residuals;
 var tmpVec = new VectorialPointValuePair(point, objective); { var
 cost = cost ; residuals = [ ] ;
 } else { cost = previousCost ; point [ cost ] = oldX [ cost ] ; } }
 xNorm = xNorm ; tmpVec *= residuals;
 gradients = [ ] ; gradients = newGradients ;
 cost = newCost;
 cost = newCost ; residuals = oldresiduals;
 gradients = [ ] ; gradients = [ ] ;
 gradients = gradients * xNorm ;
tmpVec    =  point[cost] + xNorm;
tmpVec    =  point [ xNorm ] ;
tmpVec    = residuals [ cost ] ; residuals [ cost ]
 tmpVec. residuals= residuals;
tmpVec    = residuals; tmpVec.cost = previousCost;
 cost = xNorm ;
tmpVec    = residuals ; cost = cost ;
 tmpVec [ cost ] [ delta ]= residuals;
 gradients = [ ] ; gradients = newArray ;
 gradients = gradients ; cost = cost;
tmpVec    = residuals; newRes = tmpVec;
 gradients [ cost ] = gradients [ cost];
 newCost = cost ; residuals = old_residuals;
tmpVec    = residuals [ cost ] ; residuals = [cost];
 gradients = [ ] ; gradients [ 0 ].
 gradients = [ ] ; gradients. push ( cost )
 cost = cost ; residuals = oldRes ;
 point[cost] = tmpVec;
 var tmpVec = new VectorialPointValuePair(point, objective); {};
 cost = newCost ; residuals = newresiduals;
 residuals = newresiduals;
tmpVec    = residuals [ cost ] ; residuals [ cost ] ;
 cost = newCost ; residuals = tmp_residuals;
 cost = newCost ; residuals = oldRes ;
tmpVec     = xNorm ;
 newCost = cost ; residuals = newresiduals;
 newCost = cost ; residuals = oldresiduals;
 tmpVec = _residuals;
 gradients = tmpGradients;
 tmpVec = point ; cost *= residuals;
 cost = cost ; residuals = oldresiduals;
tmpVec    = residuals; oldRes = tmpVec;
 residuals = _residuals;
 newCost = newCost ; residuals = oldresiduals;
 gradients = gradients ; residuals = oldresiduals;
 cost = cost - previousCost ; residuals = tmpVec ;
tmpVec    = residuals; } } else {
 cost = cost ; residuals = old_residuals;
tmpVec     [ cost ] = point ;
 residuals = tmpresiduals;
 cost = oldCost ;
 cost = previousCost ; }
 cost = prevCost;
 tmpVec = point [ cost ] *= residuals;
 cost = cost ; residuals = newRes ;
 gradients = newGradients ;
 var tmpVec = point [ cost ] ; point [ cost ] = tmpVec; var
 gradients = gradients ; gradients = cost;
 residuals = old_residuals;
 } tmpVec *= residuals;
tmpVec    =  newVector(); tmpVec.
 gradients = [ ] ; gradients [ 0 ] =
 cost = oldCost;
 cost = newCost ; }
 gradients = [ ] ; gradients. push =
 gradients = gradients + gradients ; gradients = gradients + gradients ; }
 cost = cost ; residuals = tmpresiduals;
 } else { cost = previousCost ; point [ cost ] = oldX[cost]; } } }
tmpVec    =  point[cost] + xNorm; this.
tmpVec    =  point[cost] ; point[cost].
 cost = cost ; residuals=residuals;
 cost = cost ; residuals = newresiduals;
 gradients = newGradients; double
 tmpVec = point [ cost ] ; cost= residuals;
 gradients [ cost ] = gradients [ cost ]
 cost = newCost ; residuals = oldRes ; } else {
 gradients = [cost]; }
 } else { cost = previousCost ; point [ cost ] = oldRes [ cost ] ; } }
 gradients = [cost]; double
 cost = newCost ; residuals = newRes ; } else {
tmpVec    = residuals [ cost ] ;
 cost = cost ; points = points;
tmpVec    =  point[cost] + xNorm; double
 cost = cost ; objective = objective;
 tmpVec = cost ; residuals= residuals;
 gradients = gradients ; gradients = 0;
 tmpVec = point.residuals;
 point[cost] = newCost;
 } tmpVec = _residuals;
tmpVec    =  point[cost] ; point[cost]
 tmpVec [ cost ] [ cost ] *= residuals;
 gradients = gradients + gradients ; gradients = gradients * gradients ; }
 gradients = gradients ; cost = previousCost;
tmpVec    = residuals; newRes = newVec;
 cost = cost ; residuals = _residuals;
 } else {
 gradients [ cost ] = gradients [ 0];
 tmpVec [ cost ++ ] *= residuals;
 gradients = gradients + gradients ; gradients = gradients - gradients ; }
 } else { tmpVec *= residuals;
 cost = cost ; points = null;
 tmpVec = point_residuals;
 tmpVec = new Vec(); oldRes *= residuals;
 tmpRes *= residuals;
tmpVec    =  point[cost] - xNorm;
 gradients = gradients ; gradients = null;
 cost *= residuals;
tmpVec     = point ;
 gradients = gradients ;
 tmpVec = cost ; previousCost *= residuals;
 residuals = prevresiduals;
 tmpVec = oldresiduals;
 cost = newCost ; residuals = 0;
 cost += cost ;
 cost = cost ; residuals = prevresiduals;
tmpVec    = residuals; newRes = newCost ;
 tmpVec [ cost ] = point *= residuals;
 cost = newCost ; residuals = null;
 cost = previousCost ; residuals = null;
 cost = oldCost - cost;
 gradients = newGradients; }
 gradients = gradients ; residuals = residual;
 point[cost] = oldCost;
 residuals = tmp_residuals;
tmpVec    = residuals [ 0 ] ;
 gradients = gradients ; }
 cost = cost ; residuals = 0;
 xNorm = cost;
 cost = cost + delta ; } else { cost = cost + delta ; } } } }
 cost = oldCost + delta;
 tmpVec = oldRes.residuals;
 tmpVec = new Vec ( ) ;
 gradients = gradients ; gradients = [ ] ; gradients = [ ] ; }
tmpVec    =  point[cost] - point[cost]; double
tmpVec     = res ;
tmpVec    = residuals [ cost ] [ delta ] ;
 tmpVec = newRes.residuals;
 tmpVec = cost ; oldCost *= residuals;
 cost = cost ; residuals = null;
 tmpVec = subresiduals;
 oldX [ xNorm ] *= residuals;
 } tmpVec = oldresiduals;
 tmpVec. cost *= residuals;
 gradients = gradients ; double
tmpVec    = residuals; oldRes = newRes ;
 oldX [cost]= residuals;
tmpVec    = residuals; cost = prevCost;
 tmpVec = x_residuals;
 cost = null;
 cost = 0 ;
 cost = newCost ; objective = objective;
 cost = oldCost = cost;
 oldX [ cost ] *= residuals;
 } else { residuals = oldresiduals;
 cost = cost + 1.0E-4 ; } } }
 } else { residuals = tmpresiduals;
tmpVec    =  point[cost] ; double
 } } else {
tmpVec     = solution ;
 oldX=residuals;
tmpVec    = residuals; gradients = null;
tmpVec     [ cost ].
 cost = cost ; residuals = point;
tmpVec    = residuals; objective = objective;
 cost = tmpCost2;
tmpVec     = new Vectorial (cost),
tmpVec     = new VectorialPoint (cost),
tmpVec    =  point[cost] ; } double
 tmpVec * *= residuals;
 tmpVec = residuals ; } }
 cost = newCost ; } }
 oldX *= residuals;
tmpVec    = residuals; this.
 gradients. add ( grad ) ; } }
 gradients = newGradients; double
 residual = oldresiduals;
 return ; }
tmpVec    = residuals; else {
 cost = prevresiduals;
 gradients. add ( gradient ) ; }
 norm = oldresiduals;
 gradients = newGradients; }
 tmpVec = xNorm ; } }
tmpVec     = new Vec (cost); double
 tmpVec *== residuals;
 cost = newCost; }
 gradients. add ( gradients ) ; }
 return cost;
 cost ++;
 gradients. add ( gradient ) ; } }
 costs = cost;
 cost = 1;
 } cost *= residuals;
tmpVec    =  newVec; double
 } tmpRes *= residuals;
 xNorm =
 tmpVec = xNorm ; } double
tmpVec     = new Vec (cost); }
tmpVec    = residuals; cost =
 cost = newCost ; } } }
 tmpVec ^= residuals;
 cost = previousCost ; } } }
 cost = prevCost ; } } }
 cost ; }
tmpVec    =  residuals; }
tmpVec    =  point [cost]; int
tmpVec     = xNorm ; }
 gradients. add ( grad ) ; } double
 } }
 previousCost *= residuals;
 tmpVec %= residuals;
tmpVec     = xNorm ; double
 } } }
 final double
 cost --;
 norm=residuals;
 cost ;
tmpVec    =  residuals; else
 oldCost *= residuals;
 error=residuals;
 res=residuals;
tmpVec    =  point ; } }
 prevRows *= residuals;
 resetCost;
 }
 previousCost= residuals;
 cost =
 reset cost;
 costs *= residuals;
tmpVec     = new
 cost %= residuals;
tmpVec     = -
tmpVec    = residuals. }
tmpVec     = --
tmpVec     } }
tmpVec    = residuals; double
tmpVec    += residuals;
 Matrix
tmpVec     } ;
tmpVec    := residuals;
tmpVec    -= residuals;
