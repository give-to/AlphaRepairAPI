boolean requiresDecomposition = false;
 boolean requiresDecomposition;
 boolean moved=false;
 boolean requiresDecomposition = decomposed=false;
 boolean needsDecomposition = false;
 boolean requiresDecomposition =!subExpression;
 boolean requiresDecomposition |= false;
 boolean decomposed= false;
 boolean needsDecomposition = decomposed=false;
 boolean needsDecomposition =! subExpression;
 boolean requiresDecomposition = false ; boolean inline = false ;
 boolean requiresDecposition=false;
 Node expressionRoot = expressionRoot ; Node subExpression = subExpression ;
 boolean isConditionalOp = isConditionalOp ( expressionRoot, subExpression ) ;
 boolean requiresDecomposition = decomposed!= false;
boolean requiresDecomposition = false ; boolean isConditionalOp = false ;
 boolean hasDecomposition = false;
 boolean isConditionalOp = isConditionalOp ( subExpression ) ;
 boolean requiresDecomposition *= false;
 Node parent = expressionRoot ; Node child = parent. getFirstChild ( ) ;
 boolean needsDecomposition;
 Node parent = expressionRoot ; Node child = subExpression ;
 boolean isConditionalOp = isConditionalOp ( expressionRoot ) ;
 Node expressionRoot = expressionRoot ; Node subExpression = subExpression. nextChild ( ) ;
 boolean requiresDecomposition =!false;
 boolean isConditionalOp = isConditionalOp ( expression ) ;
 boolean requiresDecomposition =!composed;
 boolean requiresDecomposition = done=false;
 Node expressionRoot = expressionRoot ; Node subExpression = subExpression ; Node parent = expressionRoot ;
 boolean isConditionalOp = isConditionalOp ( expressionRoot ) ; Node parent = expressionRoot ;
 boolean hasDecomposition = decomposed=false;
 Node parent = expressionRoot ; Node child = expressionRoot ; Node parent = subExpression ;
 Node expressionRoot = expressionRoot ; Node subExpression = subExpression ; Node parent = null ;
 boolean isDecomposition = false;
 boolean requiresDecomposition!= false;
 boolean needsDecomposition = decomposed==false;
 boolean isConditionalOp = isConditionalOp ( expressionRoot, subExpression )
 boolean requiresDecomposition = false ; Node parent = null ;
 boolean requiresDecomposition = decomposed==false;
 boolean requiresDecomposition = -1;
 boolean requiresDecomposition =;
 boolean needsDecposition=false;
 Node parent = expressionRoot ; Node child = expressionRoot ; Node parent = child. getParent ( ) ;
 boolean isConditionalOp = isConditionalOp ( ) ;
 boolean needsDecomposition =;
 Node expressionRoot = expressionRoot ; Node subExpression = expression ;
 boolean isConditionalOp = isConditionalOp ( expressionRoot ) ; Node parent = null ;
 Node expressionRoot = expressionRoot ; Node subExpression = subExp ;
 Node parent = expressionRoot ; Node child = expressionRoot ; Node parent = expressionRoot ;
 Node parent = expressionRoot ; Node child = expressionRoot ; Node parent = child ;
 NodeExpressionExpressionExpressionExpressionExpressionExpressionExpression;
 boolean requiresDecomposition = false ; boolean seenExpression = NodeUtil. mayHaveExpression ( subExpression ) ;
 Node parent = expressionRoot ; Node child = expressionRoot ; Node parent = child. getFirstChild ( ) ;
boolean requiresDecomposition  = false ; Node parent = expressionRoot ;
 Node expressionRoot = expressionRoot. getFirstChild ( ) ;
 Node expressionRoot = expressionRoot ; Node subExpression = subExpression. nextSibling ( ) ;
 Node expressionRoot = expressionRoot ; Node subExpression = ( Node ) subExp ;
 Node parent = expressionRoot ; Node child = expressionRoot ;
 boolean isConditionalOp = isConditionalOp ( expressionRoot, true ) ;
 Node expressionRoot = expressionRoot ; Node subExpression = subExpression. next ( ) ;
 boolean requiresDecomposition = false ; boolean seenExpression = NodeUtil. mayHaveExpression ( expressionRoot ) ;
boolean requiresDecomposition = ! expressionRoot. isUndefined ( ) ;
 NodeExpressionExpressionExpressionExpressionExpressionExpressionExpression();
 Node parent = expressionRoot ; Node child = expressionRoot ; Node parent = child. getNextChild ( ) ;
 Node parent = expressionRoot;
 Node parent = expressionRoot ; Node child = expressionRoot ; Node parent = parent. getNextSibling ( ) ;
 Node parent = expressionRoot. getFirstChild ( ) ;
 boolean needsDecomposition = decomposed!= false;
 boolean requiresDecomposition ==false;
 Node parent = (Node) subExpression;
 Node parent = (Node) expressionRoot;
 boolean requiresDecomposition = false; boolean result= false;
 boolean requiresDecomposition = false; boolean moved= false;
 boolean requiresDecomposition; boolean decomposed= false;
 boolean requiresDecomposition = decomposition!= false;
 boolean isConditionalOp = isConditional ( expression ) ;
 boolean requiresDecomposition = false; boolean executed= false;
 Node expressionRoot = expressionRoot ; Node subExpression = subExpression ; Node parent = root ;
 boolean requiresDecomposition = seenExpression==false;
 boolean needsDecomposition = done=false;
 boolean requiresDecomposition = "false;
boolean requiresDecomposition  =! expressionRoot. isFunction ( ) ;
 Node parent = expressionRoot ; Node child = parent. getFirstChild ( ) ; if ( child == null ) { return null ; }
 Node parent = expressionRoot ; Node child = parent. getNextChild ( ) ; if ( child == null ) { return null ; }
 boolean requiresDecomposition = false; boolean unrequiresDecomposition = false;
boolean requiresDecomposition = false ; boolean isConditionalOp = true ;
 boolean requiresDecomposition = descomposed=false;
boolean  requiresDecomposition = false ; try { final
 boolean decomposed;
 boolean isConditionalOp = isConditionalOp ( expressionRoot ) ; Node parent = root ;
 boolean requiresDecomposition = false ; final
 Node expressionRoot = expressionRoot ; Node subExpression = subExpression
 Node parent = expressionRoot ; Node child = parent. getFirstChild ( ) ; if (child == null) return;
 boolean isConditionalOp = false;
 Node parent = expressionRoot. getParent ( ) ;
 boolean needsDecomposition |= false;
 boolean requiresDecomposition false;
 Node parent = expressionRoot ; Node child = expressionRoot ; Node parent = null ;
 boolean isConditionalOp = isConditionalOp ( expressionRoot, subExpression ) ; final
 boolean isDecomposed = false;
 Node parent = expressionRoot ; Node child = null ;
 boolean isConditionalOp = isConditional ( ) ;
 boolean requiresDecomposition = decomposedOp==false;
boolean requiresDecomposition  = false ; if (debug) {
 boolean requiresDecomposition =!disabled;
 boolean requiresDecomposition = true=false;
boolean requiresDecomposition = false ; Node parent = ( Node ) expressionRoot ;
 boolean requiresDecomposition =!inline;
 boolean requiresDecomposition =!composed==false;
 boolean needsDecomposition =!false;
 boolean requiresDecomposition = decomposedOp=false;
 Node expressionRoot = expressionRoot. getParent ( ) ;
 Node parent = null;
 boolean needsDecomposition =! collapsed;
 boolean requiresDecomposition =!compacted;
 boolean requiresDecomposition =! collapsed;
 boolean requiresDecomposition = false; boolean _requiresDecomposition = false;
 boolean requiresDecomposition = false; boolean!requiresDecomposition = false;
 boolean requiresDecomposition = false; boolean result;
 boolean requiresDecomposition();
 boolean needsDecomp=false;
 boolean needsComposed=false;
 boolean needsDecomposition = false ; try { final
 boolean requiresDecomposition = done==false;
 boolean requiresDecomposition = false; boolean executed;
 Node expressionRoot = expressionRoot ; Node subExpression = subExpression ; try { final
 boolean requiresDecomposition = modified |= false;
 if(requiresDecomposition)requiresDecomposition = false;
 boolean needsDecomposition = done==false;
 Node parent = expressionRoot ; Node child = parent. getFirstChild ( ) ; if ( child == null ) { return null ; } final
boolean requiresDecomposition = false ; boolean isConditionalOp = null ;
 boolean requiresDecomposition = modified!= false;
 boolean requiresDecomposition =!compiled;
 Node parent = expressionRoot ; Node child = parent. getNextChild ( ) ; if ( child == null ) { return null ; } final
 boolean requiresDecomposition = false; boolean seenExpression = NodeUtil.mayHaveExpression(subExpression;
 boolean requiresDecomposition =!! subExpression ; final
 Node parent = expressionRoot ; Node child = parent ;
 boolean requiresDecomposition = false <<= false;
 boolean isConditionalOp = isConditionalOp(expressionRoot); final
 boolean requiresDecomposition =!compressed;
 Node expressionRoot = expressionRoot. getNextChild ( ) ; Node parent = expressionRoot. getFirstChild ( ) ; final
 Node expressionRoot = expressionRoot ; Node subExpression = subExpression ; Node parent = expressionRoot ; final
 boolean isConditionalOp = true;
 boolean requiresDecomposition = false; boolean *requiresDecomposition = false;
 boolean requiresDecomposition *!= false;
 Node parent = expressionRoot ; Node child = parent. getFirstChild ( ) ; if (child == null) { final
 boolean isMove=false;
 boolean requiresDecomposition =!compound;
 boolean requiresDecomposition = true <<= false;
 Node parent = expressionRoot ; Node child = expressionRoot ; Node parent = child. getFirstChild ( ) ; final
 if (requiresDecomposition == null) {requiresDecomposition = false;
 boolean requiresDecomposition =! subExpression ; final
 boolean result = false;
 boolean requiresDecomposition ; final
 Node parent = expressionRoot ; Node child = expressionRoot ; Node parent = child. getNextChild ( ) ; final
 boolean requiresDecomposition = true<= false;
 Node parent = expressionRoot ; Node child = parent. getFirstChild ( ) ; if ( child == null ) { return null ; };
 boolean requiresDecomposition =!= false;
 Node parent = expressionRoot ; Node child = expressionRoot ; Node parent = child. getNextSibling ( ) ; final
 boolean needsComposition=false;
 boolean isConditionalOp = isConditionalOp ( expressionRoot, subExpression ) ; Node parent = expressionRoot. parent ; final
 Node parent = expressionRoot ; Node child = parent. getNextChild ( ) ; if ( child == null ) { return null ; };
 Node parent = expressionRoot ; Node child = expressionRoot ; Node parent = parent. getNextSibling ( ) {
 boolean requiresDecomposition = false;requiresDecomposition = false;
 boolean needsDecomposition = false ; final
 boolean isConditionalOp = isConditionalOp ( expressionRoot ) ; Node parent = expressionRoot. nextChild ; final
 Node parent = expressionRoot ; Node child = expressionRoot ; Node parent = parent. getNextChild ( ) ; Node parent = child ; final
 boolean moved = false;
 Node parent = expressionRoot ; Node child = subExpression ; final
 Node parent = expressionRoot ; Node child = parent. getFirstChild ( ) ; if ( child == null ) { return 0 ; } final
 Node parent = (Node) expression;
 boolean hasDecomposition = false ; try { final
 if (!requiresDecomposition)requiresDecomposition = false;
 boolean isRemoved=false;
 boolean requiresDecomposition =!! expressionRoot ; final
 Node parent = expressionRoot ; Node child = parent. getFirstChild ( ) ; if ( child == null ) return null ; try { final
 boolean decomposed = false;
 boolean requiresDecomposition = false ; { final
 boolean hasDecomposition;
 boolean requiresDecomp= false;
boolean requiresDecomposition = false ; boolean isConditionalOp = false ; final
 boolean requiresDecomposition = false ; do { final
 boolean result=false;
 boolean recomposed=false;
boolean requiresDecomposition  = false ; boolean inlineCall = false ; final
 boolean requiresDecomposition
boolean requiresDecomposition  = false ; Node parent = expressionRoot ; final
 boolean result;
boolean requiresDecomposition  = false ; boolean inline = false ; final
 int index = 0;
 boolean found = false;
 boolean needsDecomposition =!= false;
 int requiresDecomposition = false ; final
 boolean requiresDecomposition * |= false;
 boolean needsDecomposition *!= false;
 boolean requiresDecompposition
 boolean matches = false;
 Node parent = (Node) subExpression();
 boolean hasDecomposition = false ; final
 boolean decomposition= false;
 Node parent = (Node) expressionRoot; final
 boolean isConditionalOp = true ; try {
 boolean requiresDecposition;
 boolean needsDecomposition = false ; { final
 boolean requiresDecomposition = false ; try { { final
 boolean decompose=false;
 boolean needsDecomposition ; final
 Node parent = (Node) expressionRoot();
boolean requiresDecomposition = false ; boolean isConditionalOp = true ; final
boolean requiresDecomposition  = false ; boolean isConditionalOp ; final
 Boolean requiresDecomposition= false;
boolean requiresDecomposition = false ; Node parent = getParent ( ) ; final
 Boolean requiresDecomposition;
 Node parent = root;
 boolean requiresDecomposition = true;requiresDecomposition = false;
 boolean needsDecomposition = false ; try { { final
 boolean moved;
 boolean requiresDecomposition = false ; boolean inline ; final
 boolean requiresComposed= false;
 boolean isDecomposed;
 boolean requiresDecomposition=requiresDecomposition = false;
 Node parent = expressionRoot();
 boolean requiresDecomposition = 0;requiresDecomposition = false;
 boolean modified=false;
boolean RequiresDecomposition = false ; final
 boolean hasDecomposition = false ; { final
 Node parent = expressionRoot ; final
 if (subExpression)requiresDecomposition = false;
 boolean isConditionalOp(); final
 boolean needsDecomp;
 boolean requiresDecomp;
 int requiresDecomposition ; final
 boolean requiresDecomp();
 boolean decomposition;
 boolean changed=false;
 if(requiresDecomposition))requiresDecomposition = false;
 if (!requiresDecposition)requiresDecomposition = false;
 if (!requiresDecomp)requiresDecomposition = false;
 boolean isConditionalOp; final
 boolean requiresDecomposition.requiresDecomposition = false;
boolean requiresDecomposition  = true ; try { final
 boolean needsDecomposition = false; #requiresDecomposition = false;
 boolean isConditionalOp(); {
 modified=false;
boolean requiresDecomposition  = 0 ; try { final
 moved=false;
 boolean isMove;
 done=false;
 boolean needsComposed;
 boolean found;
boolean  hasDecomposition ; final
 boolean decompose;
boolean requiresDecomposition  := false;
boolean requiresDecomposition  = true;
 boolean parent = null;requiresDecomposition = false;
boolean  executed;
 boolean matched;
boolean requiresDecomposition  =! subExpression && final
 Node parent;
 return null; }
 boolean parent = this.requiresDecomposition = false;
 try { final
boolean requiresDecomposition  = true ; { final
 boolean parent = root;requiresDecomposition = false;
 return null; final
 boolean parent = null,requiresDecomposition = false;
 return false; }
boolean requiresDecomposition  = true ; final
boolean requiresDecomposition = false ; boolean block ; final
 int i; final
boolean requiresDecomposition = false ; boolean visited ; final
boolean  result; final
 return false; final
 int index; final
boolean requiresDecomposition  = 0 ; { final
boolean requiresDecomposition  := false ; final
 boolean prevChild.requiresDecomposition = false;
 boolean i_requiresDecomposition = false;
boolean requiresDecomposition =  false();
 boolean m_requiresDecomposition = false;
 boolean result ; final
boolean requiresDecomposition = false ; try (final
 boolean prevChild_requiresDecomposition = false;
 boolean prevChild,requiresDecomposition = false;
boolean  found ; final
boolean  matches ; final
boolean  visited ; final
 * #requiresDecomposition = false;
 * *requiresDecomposition = false;
 *!requiresDecomposition = false;
 boolean result; #requiresDecomposition = false;
 boolean i.requiresDecomposition = false;
 boolean iUnrequiresDecomposition = false;
 boolean modified ; #requiresDecomposition = false;
 boolean i-requiresDecomposition = false;
boolean requiresDecomposition =  0 ; final
 final
boolean requiresDecomposition = false; { static
boolean requiresDecomposition (); final
boolean requiresDecomposition ); final
boolean requiresDecomposition = false. final
boolean requiresDecomposition: false;
