if (isExpressionTreeUnsafe(parent, seenSideEffects)) {
if (isSafeAssign(parent, seenSideEffects, requiresDecomposition)) {
if (isExpressionUnsafe(parent, seenSideEffects)) {
if (isSafeAssign(parent)) {
if (isSafeAssign(parent, seenSideEffects)) {
. if(isSafeAssign(parent, seenSideEffects)) {
if (isSimpleName(parent, seenSideEffects)) {
if (isSafeAssign(parent, seenSideEffects) && requiresDecomposition) {
 if ((seenSideEffects)) {
if (isSafeAssign(parent, simpleName)) {
 if ((parent, seenSideEffects)) {
if (isSafeAssign(parent, child)) {
if (isSafeAssign(parent, child, seenSideEffects)) {
if (isExpressionTree(parent, seenSideEffects)) {
 (foo) {
if (isSafeAssign(parent, seenSideEffects) || requiresDecomposition) {
 if (isSimpleName(parent)) {
.
if (isSafeAssign(parent, seenSideEffects, requiresDecomposition, false)) {
if (isSafeAssignToSimpleName(parent, seenSideEffects))
if (isSafeAssign(parent, seenSideEffects, requiresDecompositionOnly)) {
if (isSafeAssign(parent, seenSideEffects, requiresDecomposition, true)) {
if (isSafeAssign(expressionRoot, parent, seenSideEffects)) {
if (parent == expressionRoot) {
if (isSafeAssignToSimpleName(parent)) {
. if ((seenSideEffects)) {
if (isSafeAssign) {
if (isSafeAssign(parent, seenSideEffects) || isSafeAssign(child, seenSideEffects) {
 if (isExpressionTreeUnsafe(seenSideEffects)) {
 if (isSimple(parent)) {
if (isSafeAssign(parent, seenSideEffects) &&!requiresDecomposition) {
if (parent == expressionRoot)
if (isSafeAssignToName(parent, seenSideEffects)) {
. if (isSimpleName(parent)) {
if (isSafeAssign(a, seenSideEffects)) {
 if (!(parent, seenSideEffects)) {
if (isSafeAssign(parent, seenSideEffects) && isExpressionTreeUnsafe(parent))) {
if (isExpressionTreeUnsafeAssignment(parent, seenSideEffects)) {
if (isSafeAssign(parent, "foo()", seenSideEffects)) {
if (isSafeAssign(parent, "foo()")) {
 if (isSimpleName(seenSideEffects)) {
if (isSafeAssign(parent, seenSideEffects, expressionRoot)) {
if (isSafeAssign(parent, seenSideEffects) || isExpressionTreeUnsafe(parent))) {
if (isSafeAssign(parent, seenSideEffects)) { seenSideEffects = false ; } }
if (isExpressionTreeUnsafeUnsafe(parent, seenSideEffects)) {
if (isSafeAssign(parent, seenSideEffects))) {
if (isSafeAssign(parent, seenSideEffects) &&!isExpressionTreeUnsafe(parent) {
if (isSafeAssign(parent, seenSideEffects) == true) {
if (isSafeAssign(parent, seenSideEffects) && isExpressionTreeUnsafe(parent) {
if (isSafeAssign(parent, seenSideEffects) &&!isExpressionTreeUnsafe(parent))) {
if (isSafeAssignTo(parent)) {
if (isSafeAssignToSimpleName(parent, child)) {
 if (isSimpleName(parentType)) {
if (isSafeAssignTo(child)) {
if (isSafeAssign(parent, seenSideEffects))  { seenSideEffects = false ; } } }
: if (isExpressionTreeUnsafe(parent, seenSideEffects)) {
if (isSafeAssignTo) {
if (isSafeAssign(parent, seenSideEffects)) { return null ; }
if (isSafeAssignToSimpleName(child, seenSideEffects))
if (isSafeAssign(parent, seenSideEffects) || isExpressionTreeUnsafe(parent) {
if (isSafeAssign(parent, seenSideEffects) ||!isExpressionTreeUnsafe(parent))) {
. if (isSimpleName(parent, seenSideEffects)) {
if (isSafeAssign(parent, seenSideEffects) ||!isExpressionTreeUnsafe(parent) {
 if (isSimpleNameOp(parent)) {
if (isSafeAssign(parent, seenSideEffects) ||!isExpressionTreeUnsafe) {
if (isExpressionTreeUnwrapped(parent, seenSideEffects)) {
if (isSimpleName(parent, seenSideEffects))
 if (isExpressionTreeUnsafe(parent)) {
if (isSafeAssign(parent, seenSideEffects) &&!isExpressionTreeUnsafe) {
if (isSafeAssignTo(name)) {
if (isSafeAssign(child, seenSideEffects)) {
if (isSafeAssign(parent, foo)) {
if (isSafeAssignToSimpleName(parent, seenSideEffects)))
if (isExpressionTreeUnsafeName(parent, seenSideEffects)) {
. if (isExpressionUnsafe(parent, seenSideEffects)) {
 if (isSimple(parent, seenSideEffects)) {
 (foo)) {
 is safe to inline "foo()" for expressions.
if (isSafeAssign(parent, seenSideEffects) && isExpressionTreeUnsafe(parent, false) {
if (isSafeAssign(parent, seenSideEffects) || isExpressionTreeUnsafe(parent, false) {
if (isSafeAssign(parent, seenSideEffects)) { seenSideEffects = false ; }
if (isSafeAssign(parent, seenSideEffects)) { seenSideEffects = true ; } }
if (isSafeAssign(parent, seenSideEffects)) { parent = child ; } }
if (isSafeAssign(parent, foo()) {
if (isSafeAssign(parent, seenSideEffects)) { return null ; } }
if (isSafeAssign(parent, seenSideEffects))  { seenSideEffects = true ; } } }
 is safe. if (isSimpleName(parent)) {
 if (isSimpleName(child)) {
 is safe. if (isExpressionUnsafe(parent, seenSideEffects)) {
if (isExpressionTreeUnsafeAnnotation(parent, seenSideEffects)) {
 ("foo(")) {
 if (isExpressionUnsafe(seenSideEffects)) {
if (isSafeAssign(parent, seenSideEffects) == false) {
if (isSafeAssign(parent, seenSideEffects)) { return parent ; } }
if (isSafeAssign(parent, seenSideEffects) &&!isExpressionTreeUnsafe(parentType) {
: if (isSimpleName(parent)) {
if (isSafeAssign(parent,  foo))
 is safe. if(isSafeAssign(parent, seenSideEffects)) {
 if (isExpressionTreeUnsafe, seenSideEffects)) {
if (isSafeAssign(parent, seenSideEffects)) { parent = child ; } } } }
if (isSafeAssign(parent, seenSideEffects)) { return ; }
if (isSafeAssign(subExpression, parent, seenSideEffects)) {
if (isSafeAssign(a, next(), seenSideEffects)) {
if (isSafeAssign(parent, seenSideEffects) &&!isExpressionTreeUnsafe(parent)) {
if (isExpressionTreeUnsafeInline(parent, seenSideEffects)) {
if (isSafeAssign(parent, seenSideEffects)) { if (parent == expressionRoot) {
if (isSafeAssign(parent, seenSideEffects) || isSafeAssign(child, parentType) {
: if (isExpressionTree(parent, seenSideEffects)) {
if (isSafeAssign(parent, seenSideEffects) && isExpressionTreeUnsafe(parent, true) {
if (isSafeAssign(parent, seenSideEffects)) { parent = child ; } } }
if (isSafeAssign(a.x, next().x, seenSideEffects)) {
if (isSafeAssign(child)) {
if (isSafeAssign(parent, child, seenSideEffectsOnly)) {
if (isSafeAssign(parent, seenSideEffects) || isExpressionTreeUnsafe(parent, true) {
. if (isExpressionTree(parent, seenSideEffects)) {
: if (isExpressionTreeUnsafe, seenSideEffects)) {
if (isSafeAssignTo(parent, simpleName)) {
 if (isSimpleName)) {
. if (isSimpleNameOp(parent)) {
 if (isExpressionTreeUnsafe( child, seenSideEffects)) {
if (isSafeAssign(a, b, c, next(), x)) {
if (isSafeAssign(parent, seenSideEffects) ||!requiresDecomposition) {
 if (empty(seenSideEffects)) {
 is always safe. if (isSimpleName(parent, seenSideEffects)) {
if (isSafeAssign(a.x, next().x)) {
. if (isSimpleName(parentType)) {
 is safe.
 if (!empty(seenSideEffects)) {
if (isSafeAssign(parent, seenSideEffects) && isExpressionTreeUnsafe(parentType) {
if (parent.isSimpleName()) {
if (isSafeAssign(parent, seenSideEffects) && isExpressionTreeUnsafe(parent)) {
if (isSafeAssign(parent, seenSideEffects)) { return parent ; }
: if (isSimpleName(parent, seenSideEffects)) {
if (parent == expressionRoot) { return null ; }
if (isSafeAssign(parent, seenSideEffects) ||!isExpressionTree(parent))) {
if (isExpressionTreeSimpleAssignment(parent, seenSideEffects)) {
if (isSafeAssign(parent, seenSideEffects)) { seenSideEffects = true ; }
if (isExpressionTreeUnsafeCall(parent, seenSideEffects)) {
 if (isName(parent, seenSideEffects)) {
if (isSafeAssign(parent, seenSideEffects))  { parentType = parent. getType(); }
if (isSafeAssign(parent, child), seenSideEffects)) {
if (isSafeAssign(parent, seenSideEffects) || isSafeAssign(child, expressionRoot) {
 is safe. if (isSimpleName(parent, seenSideEffects)) {
if (isSafeAssignToSimpleName(parent, true)) {
if (isExpressionTreeUnsafeClause(parent, seenSideEffects)) {
 if (isExpressionTreeSafe( parent, seenSideEffects)) {
. if (isExpressionTreeSafe( parent, seenSideEffects)) {
if (isSafeAssign(parent, seenSideEffects) &&!isExpressionTree(parent))) {
if (isSafeAssign(parent, "foo()"))) {
if (isSimpleName(parent, true)) {
 is safe. if (isExpressionTree(parent, seenSideEffects)) {
if (isSafeAssign(parent, seenSideEffects) ||!isExpressionTreeUnsafe(parent)) {
 if (isExpressionTree(parent)) {
 if (isSimple(child)) {
 if (null(seenSideEffects)) {
 is safe to inline "foo()" for expressions such as "foo()".
if (child == expressionRoot) {
if (isSafeAssignToSimpleName(child)) {
if (isSafeAssign(parent, seenSideEffects)) { continue; }
if (isSafeAssign(parent,  child)) { parentType = childType ; }
if (isSafeAssign(parent, seenSideEffects) || isExpressionTreeUnsafe) {
 if (isExpressionName(parent, seenSideEffects)) {
if (isSafeAssign(parent, seenSideEffects)) { parent = child ; }
if (isSafeAssign(parent, seenSideEffects)) { break; }
if (isExpressionTreeUnconditional(parent, seenSideEffects)) {
 if (isExpressionTreeSafe(parent)) {
if (isSafeAssignToSimpleName(parent)) continue;
if (isSafeAssign(parent, seenSideEffects) || isSafeAssign(parent, expressionRoot) {
if (isSafeAssign(a, b, c, next(), foo)) {
 if (!isSimpleName(parent, seenSideEffects)) {
 is safe to inline "foo()". if (isSafeAssign(parent, seenSideEffects)) {
if (parent.isSimpleName())) {
if (isSafeAssign(parent, child, subExpression, seenSideEffects)) {
if (isSafeAssign(parent, seenSideEffects) && child == parent.getFirstChild) {
 ("foo(") {
if (isSafeAssign(parent, child, true, seenSideEffects)) {
 if (isNodeUnsafe(parent, seenSideEffects)) {
if (isSafeAssign(parent, seenSideEffects) && isExpressionTreeUnsafe(child))) {
if (isSafeAssign(a.x, child, seenSideEffects)) {
if (isSafeAssign(parent, seenSideEffects)) { return parent ; } } }
 of "foo()" is safe. if (isSafeAssign(parent, seenSideEffects)) {
if (isSafeAssign(parent, seenSideEffects)) { parentType = childType ; }
 is always safe to inline "foo()" for expressions.
if (isSafeAssign(parent, seenSideEffects, requiresDecompositionCheck)) {
 if (isSimple()) {
. if (isSimpleName(seenSideEffects)) {
 if (!inline(parent, seenSideEffects)) {
 is safe to inline "foo()" if (isSimpleName(parent, seenSideEffects)) { if (parent == expressionRoot) {
 (foo())) {
 if (!isSimpleName(parent)) {
if (isSafeAssign(parent, seenSideEffects, requiresDecomposition, expressionRoot)) {
if (isSimpleName(parent, false)) {
if (isSimpleName(parent), seenSideEffects)
if (isSafeAssign(child, subExpression, parent, seenSideEffects)) {
if (isSafeAssign(parent, seenSideEffects) == true)
 is not allowed if (isExpressionUnsafe(parent, seenSideEffects)) {
if (isSimpleName(parent))) {
if (isSafeAssign(parent, seenSideEffects)) { return null ; } } }
 is safe. if (isSimpleName(parent) {
 is not safe. if (isSimpleName(parent, seenSideEffects)) {
. if (isExpressionUnsafe(seenSideEffects)) {
if (isSafeAssign(parent, "foo()") == true) {
. if (isSimple(parent)) {
if (isSimpleName(parent, seenSideEffects)))
if (isSafeAssign(parent, seenSideEffects))  { parent = child. nextChild ; } }
. if (isExpressionTree(parent)) {
if (isSafeAssign(a, b, c, next, seenSideEffects)) {
if (isSafeAssign(parent, seenSideEffects)) { return parentType ; } }
 if (!isExpressionTree(parent, seenSideEffects)) {
if (isSafeAssign(a, b, c, d, seenSideEffects)) {
if (isSafeAssign(name)) {
if (isSafeAssign(parent, seenSideEffects)) { parent = child ; } else {
 is safe to inline "foo()" if (isSimpleName(parent, seenSideEffects)) { } } else
 is safe to inline "foo()" for expressions such as "foo();".
 is always safe. if (isExpressionTree(parent, seenSideEffects)) {
if (isSimple) {
 if (is(parent, seenSideEffects)) {
. if (isSimple(parent, seenSideEffects)) {
if (isSafeAssign(a.x, next().x, false)) {
if (isSafeAssign(a.x, next().x, true)) {
 is not allowed. if (isSimpleName(parent, seenSideEffects)) {
if (isSafeAssign(a, next(), c, seenSideEffects)) {
if (isSafeAssign(parent, child, seenSideEffects, true)) {
 is safe to inline "foo()" if (isSimpleName(parent, seenSideEffects)) { } else
 if (isSimpleName(parent, child)) {
 is safe to inline "foo()" if (isSimpleName(parent, seenSideEffects)) { if (parent == expressionRoot)
if (isSafeAssignToSimpleName(parent, foo)) {
 is safe to inline "foo()" if (isSafeAssign(child, seenSideEffects)) { } else
. if (isName(parent, seenSideEffects)) {
if (isSafeAssign(parent, child)) { return null ; } }
 if (parent, seenSideEffects)) {
if (isSafeAssign(parent, seenSideEffects) == true) { parent = child ; } }
 is not safe to inline "foo()" for expressions.
if (isSafeAssignTo(foo())) {
if (isSafeAssign(parent, child, parentType, seenSideEffects)) {
if (isSafeAssign(parent,  child)) { parentType = child. type ;
if (isSafeAssign(a, next(), child, seenSideEffects)) {
if (isSafeAssign(parent, child)) { return null ; }
if (isSafeAssign(subExpression, child, parent, seenSideEffects)) {
 is safe to inline "foo()" if (isSimpleName(parent, seenSideEffects)) { parent = parent. parent ; } else
if (isSafeAssign(parent, node, seenSideEffects)) {
if (isSafeAssign(parent, seenSideEffects, subExpression)) {
if (isSafeAssign(parent, name)) {
if (isSafeAssign(child, simpleName)) {
if (parent == expressionRoot) { } } }
if (isSafeAssign(parent, child, seenSideEffects, false)) {
 is safe to inline "foo()" if (isSimpleName(parent, seenSideEffects)) { if (parent!= expressionRoot) {
 is not allowed. if (isExpressionTree(parent, seenSideEffects)) {
 is not safe. if (isExpressionTree(parent, seenSideEffects)) {
if (isSafeAssign(a, b, c, next()) ) {
. if (!seenSideEffects)) {
: if (isSimpleName(parent) {
 if (!isSimpleName(seenSideEffects)) {
if (isSafeAssign(parent, seenSideEffects)) { } } }
 is safe to inline "foo()" if (isSimpleName(parent, seenSideEffects)) { return null; } else
. if (isSimpleName(parent) {
 if (isExpressionTreeUnsafe(child)) {
if (isSafeAssign(parent, seenSideEffects, true, requiresDecomposition)) {
if (isSafeAssign(parent, seenSideEffects) == false) { return null; }
 is allowed. if (isSimpleName(parent, seenSideEffects)) {
 is safe to inline "foo()" if (isSimpleName(parent, seenSideEffects)) { parent = child. parent ; } else
if (isSafeAssign(parent, seenSideEffects)) { } } } }
if (isSafeAssign(parent, seenSideEffects) && parent.isExpressionTreeUnsafe) {
if (isSafeAssignTo()) {
if (isSafeAssign(parent, seenSideEffects) == true) { return null; }
if (isSafeAssign(parent, seenSideEffects) == true) { return null ; } }
if (isSafeAssign(parent, seenSideEffects)) continue;
if (isSafeAssign(parent, seenSideEffects) == false) { return null ; } } }
if (isSafeAssign(parent, seenSideEffects) == false) { return null ; } }
if (isSafeAssign( parent, child, seenSideEffects))) {
if (parent == "foo()") {
 if (isSimpleExpression(seenSideEffects)) {
 is safe to inline "foo()" if (isSimpleName(parent, seenSideEffects)) { return null ; } } else
if (isSafeAssign(parent, seenSideEffects) == true) { return parent ; } }
if (isNameUnsafe(parent, seenSideEffects)) {
 of "foo()" is safe.
 is safe to inline "foo()" if (isSimpleName(parent, seenSideEffects)) { parent = child ; } } else
 is safe to inline "foo()" if (isSimpleName(parent, seenSideEffects)) { return parent ; } } else
if (isSafeAssign(a, next(), parentType, seenSideEffects)) {
if (isSafeAssign(parent, seenSideEffects, requiresDecomposition == true)) {
 is safe to inline "foo()" if (isSimpleName(parent, seenSideEffects)) { } } } else
 is safe to inline "foo()" if (isSimpleName(parent, seenSideEffects)) { return; } else
if (isSafeAssign(parent, seenSideEffects, requiresDecomposition, parentType)) {
if (isSafeAssign(parent, seenSideEffects, requiresDecomposedName)) {
if (isSafeAssign(a.x, next().x())) {
 if(unsafe(parent, seenSideEffects)) {
if (isSafeAssign(child, seenSideEffects)) continue;
if (isSafeAssign(parent, seenSideEffects) &&!isExpressionTree(parent)) {
 is safe to inline "foo()" for expressions such as "foo".
if (isSafeAssign(parent,  "foo()")) { return null ; }
if (isSafeAssign(parent, "foo()") == false) {
 is safe to inline "foo()" if (isSimpleName(parent, seenSideEffects))) { if (parent == expressionRoot)
 is safe to inline "foo()" if (isSimpleName(parent, seenSideEffects)) { return parent ; } else
if (isSafeAssign( child, parent)) {
 if (isEmpty(seenSideEffects)) {
. if (isExpressionName(parent, seenSideEffects)) {
 is safe to inline "foo()" if (isSimpleName(parent, seenSideEffects)) else
if (isSafeAssign(parent, expressionRoot, seenSideEffects)) {
if (isSimpleName(parent))
if (isSafeAssign(parent, seenSideEffects, requiresDecomposition == false)) {
 if (isSimpleName(child, seenSideEffects)) {
 is safe to inline "foo()" if (isSimpleName(parent, seenSideEffects)) { parent = parent. next(); } else
. if (isExpressionTreeSafe(parent)) {
if (isSafeAssign(a, b, c, d)) {
if (isSafeAssign(child, foo()) {
if (isSafeAssignTo(parent, foo)) {
if (isSafeAssign(child, parent, parentType, seenSideEffects)) {
if (isSafeAssign(parent, seenSideEffects) ) { parent = child. next ( ) ;
 if (isString(parent, seenSideEffects)) {
if (isSafeAssign(child, foo)) {
 is safe to inline "foo()" if (isSafeAssign(parent, seenSideEffects)) { } else
 is safe to inline "foo()" for expressions such as "a = foo();".
 is always safe. if (isSimpleName(seenSideEffects)) {
 is safe if (isSimpleName(parent, seenSideEffects)) {
if (isSafeAssign(parent, seenSideEffects) && child == subExpression) {
if (isSafeAssignToSimpleName(parent, foo()) {
 is safe to inline "foo()" if (isSimpleName(parent, seenSideEffects)) { else
 is safe to inline "foo()" if (isSimpleName(parent, seenSideEffects)) { if (parent!= null) {
if (isSafeAssign(parent, seenSideEffects)) { return parent ; } else {
 is safe to inline "foo()" if (isSafeAssign(parent, seenSideEffects)) { } } else
if (isSafeAssign(parent, seenSideEffects) == true) { return parent ; } } }
if (isSafeAssign(parent, seenSideEffects) || isSafeAssign(child, parent) {
if (isSafeAssign(parent, seenSideEffects) && parent.isSimpleName()) {
if (isSafeAssign(parent, seenSideEffects) &&!isExpressionTree(parentType) {
 if (isSimpleName(parent) {
. if (isSimpleName)) {
if (isSafeAssign(expressionRoot, subExpression, parent, seenSideEffects)) {
if (parent == expressionRoot) { } else {
 is safe to inline "foo()" if (isSimpleName(parent, seenSideEffects)) { } else {
. if ((parent, seenSideEffects)) {
 is safe to inline "foo()" for expressions. else
if (isSafeAssign(this, child, subExpression, parent, seenSideEffects)) {
if (isSafeAssign(parent, seenSideEffects, true)) {
 is safe to inline "foo()" if (isSimpleName(parent, seenSideEffects)) { } else { } else
 is safe to inline "foo()" for expressions such as "a".
if (isSafeAssign( parent, child, seenSideEffects)) continue;
if (isSafeAssign(a, b, c, seenSideEffects)) {
 if (isSimpleName, seenSideEffects)) {
if (isSafeAssign(parent, seenSideEffects) ||!isExpressionTree(parent)) {
if (isSafeAssign(parent, seenSideEffects, requiresDecompositionFlag)) {
if (isSafeAssign(parent, seenSideEffects) && isExpressionTreeUnsafe()) {
 if (isName(parent)) {
 is safe to inline "foo()" for expressions such as "a = b".
 is safe to inline "foo()" if (isSafeAssign(child, seenSideEffects)) } else
if (isSafeAssign(parent, name, seenSideEffects)) {
 is safe to inline "foo()" if (isSimpleName(parent, seenSideEffects)) {
if (isSafeAssign(parent, seenSideEffects) && isExpressionTree(parent))) {
if (isSafeAssign(expressionRoot, child, parent, seenSideEffects)) {
 is always safe. if (isName(parent, seenSideEffects)) {
 is safe to inline "foo()" if (isSimpleName(parent, seenSideEffects)) { if (parent == child)
if (isSafeAssign(parent, seenSideEffects, requiresDecomposition?)) {
 is safe to inline "foo()" for expressions with simple LHS values.
 is safe to inline "foo()" if (isSimpleName(parent, seenSideEffects)) } else
 is safe to inline "foo()" for expressions such as "foo();"
if (isSafeAssign(a, b, c, foo()) ) {
if (isSimpleName) {
 is safe to inline "foo()" for expressions such as "foo().
 is safe to inline "foo()" if (isSafeAssign(parent, seenSideEffects)) {
if (isSafeAssign(parent, "foo")) {
if (isSafeAssign(parent, seenSideEffects, child, requiresDecompositionOnly)) {
 is safe to inline "foo()" if (isSafeAssign(child, seenSideEffects)) { else
if (isSafeAssign(parent, seenSideEffects) && parentType == simpleName) {
 is safe to inline "foo()" for expressions of "foo()".
 if (isSimpleNode(parent, seenSideEffects)) {
 is safe to inline "foo()" if (isSimpleName(parent, seenSideEffects)) { } else { } } else
 is safe to inline "foo()" for expressions like "foo()".
 is safe to inline "foo()" if (isSimpleName(parent, seenSideEffects)) { parent = child ; } } }
 is safe to inline "foo()" for expressions such as "a = b = foo();".
if (isSimple)) {
 is safe to inline "foo()" for expressions such as "a = b = foo();"
if (isSafeAssign(parent, parent.getFirstChild())) {
if (isSafeAssign(child, seenSideEffects)) break;
 if (empty(parent, seenSideEffects)) {
if (isSafeAssign(parent, seenSideEffects, parent.getFirstChild(), false)) {
. if (isSimpleName, seenSideEffects)) {
 is safe to inline "foo()" for expressions such as "a = foo();"
if (isSimpleExpression(parent, seenSideEffects)) {
 is safe to inline "foo()" if (isSafeAssign(parent, simpleName)) { } else
if (isSafeAssign(parent, seenSideEffects) == true) { break; }
if (isSafeAssign(parent, simpleName)) continue;
if (isSafeAssign(a, b, c) == true)
 is safe. if (isSimpleName) {
 is safe to inline "foo()" if (isSimpleName(parent, seenSideEffects)) { return; } } else
 is safe to inline "foo()" if (isSafeAssign(parent, simpleName)) { } } else
if (isSafeAssign(a, b)) {
 is not allowed. if (isSimpleName(seenSideEffects)) {
if (isSafeAssign(parent, seenSideEffects) || isExpressionTreeUnsafe()) {
 is safe to inline "foo()" if (isSimpleName(parent), seenSideEffects) else
if (isSafeAssign(parent, "foo()")) { return ; }
if  possible.
 is safe. if (isSimpleNameSafe(parent, seenSideEffects)) {
if (isSafeAssign(parent, seenSideEffects)) { } } } } }
 is not safe. if (isSimpleName(seenSideEffects)) {
 if (isExpressionTree(seenSideEffects)) {
 is safe to inline "foo()" if (isSimpleName(parent), seenSideEffects)) { } else
if (isSafeAssign( parent, child, seenSideEffects)) break;
 is safe to inline "foo()" for expression trees.
. if (seenSideEffects)) {
if (isSafeAssign(parent, seenSideEffects) == true) { } } }
if (isSafeAssign(parent, "foo()") {
 is safe. if (parent == expressionRoot) {
. if (!(parent, seenSideEffects)) {
if (isSafeAssign(a, next(), next().x, seenSideEffects)) {
 is not allowed. if (parent == expressionRoot) {
 like "foo(){
if (isSafeAssign(parent, seenSideEffects) || isSafeAssign(parent, child) {
if (isSafeAssign(parent, seenSideEffects)) { continue; } }
 if (!( child, seenSideEffects)) {
 is safe to inline "foo()" if (isSafeAssign(parent, simpleName)) } else
if (isSafeAssign(child, seenSideEffects))) {
 like foo(){
 if (isSimpleNameNode(seenSideEffects)) {
if  there is no name assigned-to.
 of "foo()" for expressions. if (isSafeAssign(parent, seenSideEffects)) {
 is safe to inline "foo()" if (isSimpleName(parent, seenSideEffects)) { }
 is safe if (isExpressionTree(parent, seenSideEffects)) {
if (isSafeAssignTo(foo()) {
if (isSafeAssign(a.x, parent, seenSideEffects)) {
 is safe to inline "foo()" for expressions such as "foo()"
 is safe to inline "foo()" here.
if (isSafeAssign(parent, "foo()")) { break; }
if (useSimpleName)
if (isSafeAssign(parent, seenSideEffects) || isExpressionTree(parent))) {
if (isSafeAssign(parent, seenSideEffectsOnly)) {
 is safe. if (isSimple(parent) {
 if (!isName(parent, seenSideEffects)) {
 if (isString(seenSideEffects)) {
if (isSafeAssign(parent, seenSideEffects, parent.getFirstChild(), true)) {
if (isSafeAssign(parent, seenSideEffects) == true) { return ; }
 is safe to inline "foo()" if (isSimpleName(parent, seenSideEffects)) or
 of "foo()" is not allowed.
if (isSafeAssign(parent, seenSideEffects) ||(parent == expressionRoot) {
 is safe to inline "foo()" for expressions such as "a = b = c";
 ("foo()) {
 is safe to inline "foo()" if (isSimpleName(parent, seenSideEffects)) { } else { else
 of "foo()" is safe if (isSafeAssign(parent, seenSideEffects)) {
if (isSimpleName()) {
 is always safe. if (parent == expressionRoot) {
if (isSafeAssign(parent, seenSideEffects) &&!isExpressionUnsafe) {
 if (isSimpleNameOp(seenSideEffects)) {
if (isSafeAssign(parent, child), seenSideEffects == false)) {
 is safe to inline "foo()" for expressions of the same name.
 is safe to inline "foo()". if (!isSafeAssign(parent, seenSideEffects)) {
if (isSafeAssign(a.x, next().x++)) {
 is safe to inline "foo()" if (isSafeAssign(parent, seenSideEffects)) { } else {
 is safe to inline "foo()" for expressions such as "a = foo()".
. if (!inline(parent, seenSideEffects)) {
if (isSafeAssign(a, b, seenSideEffects)) {
 is safe to inline "foo()" for expression.
if (isSafeAssign(child, parentType, seenSideEffects)) {
 is always safe. if (parent == simpleName) {
if (isSafeAssign(parent, "foo()"))
if (isSafeAssign(parent, "foo()")) { } } }
if (isSafeAssign(parent, seenSideEffects) ||!isExpressionUnsafe) {
: if (parent == expressionRoot) {
 is safe. if (parent == child) {
 if (isSimpleName(parent,!seenSideEffects)) {
. if (empty(seenSideEffects)) {
if (isSafeAssign(parent))) {
if (isSafeAssign(this, child, parentType, parent, seenSideEffects)) {
 ("foo")) {
 is safe to inline "foo()" for expressions such as "a = b = foo();" else
 of "foo()" is not safe.
 is safe to inline "foo()" if (isSimpleName(parent), seenSideEffects)) { else
if (isSafeAssign(parent, seenSideEffects) || isSafeAssign(child))) {
 is safe to inline "foo()" for expressions such as "a = b = c".
if (isSafeAssign(parent, subExpression, seenSideEffects)) {
if (isSafeAssign(parent, child, subExpression, parent, seenSideEffects)) {
 is always safe. if (isSimpleName) {
if (isSafeAssign(a, b, cName, seenSideEffects)) {
if (isSafeAssign(parent, seenSideEffects)) break;
 is not allowed for expressions such as "foo(){
 is always safe. if (isSimple(parent, seenSideEffects)) {
 is not safe. if (isSafeAssign(parent, seenSideEffects)) {
if (isSafeAssign(child, parentType, parent, seenSideEffects)) {
if (isSafeAssign(a.x, simpleName)) {
 is safe. if (safe) {
 is always safe. if (isSimple(parent) {
if (isSafeAssign(parent, "foo()") == true)) {
 if (isExpressionNode(parent, seenSideEffects)) {
 if (inline(parent, seenSideEffects)) {
 means "foo()" for simple expressions.
if (isSafeAssign(parent, seenSideEffects, false)) {
 is always safe. if (isSafeAssign(parent, seenSideEffects)) {
 of "foo()" is not allowed in LHS expressions.
 is always safe. if (!isSimpleName(seenSideEffects)) {
if (name == foo()) {
 if (isSimpleName(parent),!seenSideEffects)) {
 is safe to inline "foo()".
 if (!isEmpty(seenSideEffects)) {
 is safe to inline "foo()" for expressions of the same type.
 is safe to inline "foo()" for expressions such as "a = b"
if (isSafeAssign(parent, seenSideEffects)) return null;
 is safe to inline "foo()" for expressions such as "foo()" here.
 is safe to inline "foo()" for expressions such as "a = b = foo()".
 is safe to inline "foo()" for expressions such as "foo()".
 is safe to inline "foo()" for expressions such as "foo()" below.
if (parent == node) {
 is safe to inline "foo()" for expressions such as "a = b";
 means "foo()" for a simple expression.
if (isSafeAssign(child, parent, seenSideEffects)) {
if (isSafeAssignToSimpleName())
if (isSafeAssign(parent, child, seenSideEffects*)) {
 is safe to inline "foo()" for expressions such as "foo();".
 is always safe. if (parent == child) {
if (isSafeAssign(foo())) {
. if (!isSafeAssign(parent, seenSideEffects)) {
: if (parent == child) {
 is safe to inline "foo()" for expressions such as "a = b = c"
 of "foo()" is not possible.
 if (!isString(seenSideEffects)) {
 is safe to inline "foo()" for expressions such as "a = b = foo();",
 expression. if (isSafeAssign(parent, seenSideEffects)) {
if (inline) {
 is safe to inline "foo();". if(isSafeAssign(parent, seenSideEffects)) {
 is not allowed. if (parent == child) {
 is safe to inline "foo()" else if(isSafeAssign(parent, seenSideEffects)) {
 is safe to inline "foo()" for expressions such as "foo".
if (isSafeAssign(parent, child, seenSideEffectsAlways)) {
 if (isSimpleCall(parent, seenSideEffects)) {
 if (!is(parent, seenSideEffects)) {
 is safe to inline "foo()" for expressions such as "a = b = foo()"
if (isSafeAssign(child, parent, parentType, parent, seenSideEffects)) {
 is always safe to inline "foo()" here.
if (isSafeAssign(parent, child), seenSideEffectsOnly)) {
 if (!seenSideEffects)) {
if  no name is given.
if (isSafeAssign(parent, seenSideEffects) == true) return null;
 if ($(parent, seenSideEffects)) {
 of foo(). if(isSafeAssign(parent, seenSideEffects)) {
if (isSafeAssign(parent, seenSideEffects) || usesDecomposition) {
if (isSimpleNameUnsafe(parent, seenSideEffects)) {
 is safe to inline "foo()" for expressions. } else
if (isSafeAssign(foo(), parentType, seenSideEffects)) {
 is safe to inline "foo()" for expressions like this.
 is safe to inline "foo()" for expressions such as "a = b = foo";
 is safe to inline "foo()" for functions.
if (isSafeAssign(child, expressionRoot, parent, seenSideEffects)) {
if (isSafeAssign(parent, seenSideEffects) || parentType == simpleName) {
if (isSafeAssign(a.x, foo())) {
if (isNodeTreeUnsafe(parent, seenSideEffects)) {
if (isSafeAssign(name))
 is safe to inline "foo()" for expressions like this:
 is safe to inline "foo()" for expressions:
if (isSafeAssign(parent, seenSideEffects) == false)
if (isSafeAssign(parent, seenSideEffects)!= true) {
if (isSafeAssign(parent, seenSideEffects) && parentType == "name") {
if  the expression is unsafe.
if (isSafeAssignToSimpleName)
if (isSafeAssign(parent, seenSideEffects) && needsDecomposition) {
if (isSafeAssign(parent, seenSideEffects) == false) continue;
if (isSafeAssign(parent, seenSideEffects))) break;
if (isSafeAssign(parent, seenSideEffects)!= false) {
 if (isSimple(parent) {
 is safe to inline "foo()". else if(isSafeAssign(parent, seenSideEffects)) {
if (isSafeAssign(parent, seenSideEffects)) { } }
 of "foo()" is not allowed for LHS expressions.
if (isSafeAssign(parent, child, parentType, parent, seenSideEffects)) {
 is safe to inline "foo()." if(isSafeAssign(parent, seenSideEffects)) {
if (isSafeAssign(parent, seenSideEffects) == true) continue;
 if (!empty(parent, seenSideEffects)) {
if (isSafeAssign(parent, child, child, child, parent, seenSideEffects)) {
if (isSafeAssign(parent, "foo()", true)) {
 (foo()) {
if (isSafeAssign(child, seenSideEffectsOnly)) {
if (isSafeAssign(parent, seenSideEffects) || parentType == expressionRoot) {
if (isSafeAssign(parent, seenSideEffects) && child == parent) {
 if (parent == child)) {
if (isSafeAssign(parent, parent, parentType, parent, seenSideEffects)) {
 is safe to inline "foo()" for expressions such as "foo();"
 if (parent == child) {
 of "foo()" is not allowed in a LHS expression.
 is safe. if (parent == name) {
if  no name is provided.
 is safe to inline "foo()" for expressions such as "a = b."
 is safe to inline "foo()" for expressions of the same kind.
 is safe to inline "foo()" for expressions
 is safe to inline "foo()" for expressions of the same name. else
 if (isSimpleNode(seenSideEffects)) {
 like "foo()"{
 to a simple expression. if(isSafeAssign(parent, seenSideEffects)) {
if (isSafeAssign(parent, seenSideEffects) || parentType == "name") {
if (isSafeAssign(parent, seenSideEffects, parentType)) {
 is safe to inline "foo()" for expressions such as "a = b = foo".
if (isNameTreeUnsafe(parent, seenSideEffects)) {
if  "foo()" exists.
if (isSafeAssignTo)) {
if (isSafeAssign(parent, seenSideEffects) == true)) {
 to foo(). if(isSafeAssign(parent, seenSideEffects)) {
 of "foo()" is not allowed in an LHS expression.
if (isSafeAssign(parent, seenSideEffects)) return;
if (isSafeAssign(parent, "foo()", false)) {
 is safe to inline "foo()" for expressions. }
 of "foo()" is not allowed in this case.
 is safe to inline "foo()" for expressions such as "foo";
if (isSafeAssign(parent, seenSideEffects) || parent == child) {
 if (if (!seenSideEffects)) {
 if (isSimpleName(child) {
 is safe to inline "foo()" for expressions such as "foo()". else
if (ISExpressionTreeUnsafe(parent, seenSideEffects)) {
if (isSafeAssign(parent, seenSideEffects) == true) { } }
if (isSafeAssign(parent)) continue;
if (isSafeAssign(parent, "foo()")) { } }
 of "foo()" is not allowed in LHS values.
 of "foo()" is not allowed in expressions.
 of "foo()" is not safe for inline expressions.
if (isSafeAssignTo(foo))
 ("foo()".) {
 of "foo()" in an expression is not allowed.
if (isSafeAssign(parent, seenSideEffects) && parent.isSimple ( )) {
 is safe. if (isSimpleNameNode(seenSideEffects)) {
 if (isSimpleCall(seenSideEffects)) {
if (isExpressionNodeSafe(parent, seenSideEffects)) {
 is safe to inline "foo()" for expressions such as "foo()"
if (isSafeAssign(parent, seenSideEffects) || isSafeAssign(child)) {
 is not allowed for expressions such as foo(){
 of "foo()" is not allowed in expression trees.
 ("foo)) {
. if (parent == child) {
if (isSafeAssign(foo()))) {
if (isSafeAssign(parent, subExpression, parent, seenSideEffects)) {
if (isSafeAssign(parent)) break;
. if (isSimple(parent) {
if  any.
 is safe to inline "foo();".
if  "foo()" occurs.
 is safe to inline "foo()" for expressions such as "foo();" else
if (isSafeAssign(parent, expressionRoot, parent, seenSideEffects)) {
 of "foo()" for expressions if (isSafeAssign(parent, seenSideEffects)) {
if (isSafeAssign(a.x, childName, seenSideEffects)) {
 if (all(seenSideEffects)) {
if (isSafeAssign(a, b, c) == true).
 like "foo()":{
if (isSafeAssign(parent, child).inline(child, parent, seenSideEffects)) {
 of "foo()" is not allowed for LHS values.
if (isSafeAssign(parent, seenSideEffects) || parentType == expressionType) {
 is safe to inline "foo()" for expressions such as "foo();". else
 is safe to inline "foo()" for expressions with no side-effects. } else
if (isSimpleName(parent)) { }
if (isSafeAssign(parent, child, child.x, parent, seenSideEffects)) {
if (isSafeAssignToSimpleName(parent)) { }
 of "foo()" is safe.{
if (isSafeAssign(parent, seenSideEffects) == false) { } }
 is safe to inline "foo()" for expressions such as this.
if (IsExpressionTreeUnsafe(parent, seenSideEffects)) {
("foo(b) {
 is safe to inline "foo()" for expressions such as this:
if  no name given.
 of "foo()" for expression if (isSafeAssign(parent, seenSideEffects)) {
 is safe to inline "foo()" for expressions such as "foo()". } else
 is safe. if (!isSafeAssign(parent, seenSideEffects)) {
if (isExpressionNodeUnsafe(parent, seenSideEffects)) {
 like "foo()"){
 of "foo()" is safe if (!isSafeAssign(parent, seenSideEffects)) {
if (isSafeAssign(parent, seenSideEffects) && parent!= child) {
if (name) {
 is always safe to inline "foo()". else
 is safe. if (isSimple) {
 is safe to inline "foo()" for expression trees. else
 of "foo()" is not allowed.{
if (isSafeAssign(parent, seenSideEffects) && expressionRoot) {
 of "foo()" is allowed.{
 is safe to inline "foo();" else if(isSafeAssign(parent, seenSideEffects)) {
 is safe to inline "foo()" for expressions. } }
if (isSafeAssignments)
if (isSafeAssign(parent, seenSideEffects) && parentType == expressionType) {
 (foo(b)) {
if (isSafeAssign(foo))
 if (seenSideEffects)) {
if (isSafeAssign(child, expressionRoot, seenSideEffects)) {
 is safe to inline "foo()" for example
 if (Expression.isSafeAssign(parent, seenSideEffects)) {
if (isSafeAssign(a, c)) {
 is safe to inline "foo()" for expressions such as "foo()" } else
 is safe to inline "foo()" for expressions such as "foo()" else
if  "foo()" is used
if  it exists.
 is not allowed for expressions such as "foo{
 if (!safe(parent, seenSideEffects)) {
 (foo(abc)) {
if  necessary.
 is not allowed for expressions such as "foo("{
 of "foo()" for expressions like{
if (isSafeAssign(parent, seenSideEffects) && parent.isName (...)) {
 is always safe to inline "foo()" else
if (isSafeAssign(parent, parentType, parent, seenSideEffects)) {
 of "foo()" is safe. else
 like "foo(b){
 is safe to inline "foo()". else
 of "foo()" is unsafe.{
("foo(c) {
if (isSafeAssign(parent, seenSideEffects)) { }
 is safe to inline "foo()" for expressions such as "foo()". }
if (isSafeAssign(a, simpleName)) {
 if (!isSafeAssign(parent, seenSideEffects)) {
 is not safe. if (!isSafeAssign(parent, seenSideEffects)) {
(foo(a, seenSideEffects)) {
 is not safe.
 is safe to inline "foo().".
 is always safe for inline calls. if(isSafeAssign(parent, seenSideEffects)) {
 of "foo()" for expressions such as `{
 is not allowed for expressions such as "foo().{
 for "foo()"{
 is safe to inline "foo()" for expressions such as "foo();" } else
 of "foo()" if (this.isSafeAssign(parent, seenSideEffects)) {
 is safe to inline "foo()" if if(isSafeAssign(parent, seenSideEffects)) {
 is safe to inline "foo()" for expressions with no side-effects. } }
if (isSafeAssign(parent, seenSideEffects) || parent.isName (...)) {
 to a simple name. if(isSafeAssign(parent, seenSideEffects)) {
if (isExpressionNameUnsafe(parent, seenSideEffects)) {
if (isSafeAssign(parent, seenSideEffects, needsDecomposition)) {
 if (!(seenSideEffects)) {
 is safe to inline "foo()."
 is safe to inline "foo()" for expressions such as: else
 ("foo()") {
 is always safe. if (this.isSafeAssign(parent, seenSideEffects)) {
 is unsafe. if (isSafeAssign(parent, seenSideEffects)) {
 if ((child, seenSideEffects)) {
if (isSafeAssign(a, next())) {
if (isSimpleName(parent)))
 is safe to inline "foo()" for expressions like this: else
 like "foo("){
if  needed.
if (isSafeAssignToSimpleName(parent)) continue.
 like "foo("abc")){
if (isSafeAssignName()) {
if (isSafeAssign(parent, seenSideEffects) || child == parent) {
: if (isSafeAssign(parent, seenSideEffects)) {
, like "foo(b)){
 is safe to inline "foo()" for expressions like this. else
if (isSafeAssign(parent, "foo()") == true) { }
 like "foo(b)){
 foo(){
 (parent, seenSideEffects)) {
if  a simple expression.
, like "foo(b){
if (isSafeAssign(parent, seenSideEffects)) { continue }
if (isSafeAssign(parent, seenSideEffects, true, false)) {
if (isSafeAssign(foo()) {
 of "foo()" is safe
 is always safe. } else if(isSafeAssign(parent, seenSideEffects)) {
 is safe. } else if(isSafeAssign(parent, seenSideEffects)) {
 is safe to inline "foo()" else
 if (parent == null) {
 is not safe. if (this.isSafeAssign(parent, seenSideEffects)) {
if (isSafeAssign(parent, seenSideEffectsTrue)) {
if (isSafeAssign()) {
 is always safe for inline expressions. if(isSafeAssign(parent, seenSideEffects)) {
 like "foo()" -{
if (isSafeAssign(parent, expressionName, seenSideEffects)) {
if (isSafeAssign(child))
 if (inlineCall) {
if (simple) {
if (true) {
 if (parent!= child) {
if (isSafeAssign(parent, seenSideEffects) || parent.isName ())) {
 of "foo()" for expressions like `{
if (isSafeAssign(parent, "foo()")) { }
if (isSafeAssign(this.x, parent, seenSideEffects)) {
if  no name specified.
if (isSafeAssign(parent, seenSideEffects, true, true)) {
 is not safe. } else if(isSafeAssign(parent, seenSideEffects)) {
 of "foo()" is not allowed in LHS expressions!
 of "foo()" for expressions like "{
 is always safe. if (Helper.isSafeAssign(parent, seenSideEffects)) {
 of "foo()" for expressions.{
 is always safe. if (!isSafeAssign(parent, seenSideEffects)) {
if (isSafeAssign(parent,  "foo()") == false) { }
if (isSafeAssign(parent, seenSideEffects) == true)) { } }
 of "foo()" is not safe!
if  "foo()" is inline
, like "foo(a)){
 expression if (isSafeAssign(parent, seenSideEffects)) {
 if (isName)) {
 if (parent == name) {
 is safe. if (this.isSafeAssign(parent, seenSideEffects)) {
 ("foo()")) {
if  no name provided.
 of "foo()" if(!isSafeAssign(parent, seenSideEffects)) {
 if (this.isSafeAssign(parent, seenSideEffects)) {
if (isSafeAssign(parent, seenSideEffects)) return parent ;
 ((foo)) {
if (isUnsafe(parent, seenSideEffects)) {
( child, seenSideEffects)) {
, like "foo("foo")){
 of "foo()" is not allowed in a LHS expression!
 node. if(isSafeAssign(parent, seenSideEffects)) {
if (isSafeAssign(parent, seenSideEffects) && child!= parent) {
if (isSafeAssign(this, child, null, parent, seenSideEffects)) {
if (true)
 of "foo()". if(isSafeAssign(parent, seenSideEffects)) {
 of "foo()" is not allowed in an LHS expression!
 like "foo("abc"){
, like "foo()" -{
 of "foo()" else if(isSafeAssign(parent, seenSideEffects)) {
if (isSafeAssign(subExpression.x, parent, seenSideEffects)) {
 if (!isSimple)) {
if (isSafeAssign(parent, seenSideEffects) && usesDecomposition) {
if (isSafeAssign(parent, seenSideEffects)) { continue ;
if (isSafeAssign(parent, seenSideEffects) && parent == child) {
 is safe. else if(isSafeAssign(parent, seenSideEffects)) {
if (isSafeAssignTo(child)) { }
 of "foo()" is not allowed in a LHS expression:
 of "foo()". else if(isSafeAssign(parent, seenSideEffects)) {
if  "foo()" exists
if (isSafeAssign(parent, seenSideEffects, satisfiesDecomposition)) {
if (isSafeAssign(parent, seenSideEffects*)) {
if (isSafeAssign(parent, seenSideEffects, requiredDecomposition)) {
 is always safe to inline foo(). else
 of "foo()" in an expression is not allowed!
. if(parent, seenSideEffects)) {
if (isSafeAssign(parent))
if (isSafeAssign(parent, seenSideEffectsAlways)) {
 is safe. } } if(isSafeAssign(parent, seenSideEffects)) {
if (isSafeAssign(parent, seenSideEffects) && child!= null) {
 is always safe. else if(isSafeAssign(parent, seenSideEffects)) {
 is not safe. } else
if (isSafeAssign(parent,  true))
 to foo().
if (isSafeAssign(parentType, parent, seenSideEffects)) {
if (isSafeAssign(parent, seenSideEffects) || parentType == 0) {
 means "foo()" for a simple expression:
 is safe. else
if (isSafeAssign(parent, seenSideEffects) &&!inline) {
if (isSafeAssign(parent, seenSideEffects, child, true)) {
if (isSafeAssign(parentType, seenSideEffects)) {
 is always safe. } else
 in expression. if(isSafeAssign(parent, seenSideEffects)) {
if (isSafeAssign(parent, seenSideEffects) || parentType == 1) {
if (name)
 means "foo()" for a simple expression!
 is not safe.{
 is not allowed. } else
if (isSafeAssign(parent,  name))
 of "foo()" means "foo()".
if  "foo()" occurs
 of foo()... if(isSafeAssign(parent, seenSideEffects)) {
 in expression tree if(isSafeAssign(parent, seenSideEffects)) {
 of "foo()" is not allowed in expressions!
if (expressionRoot)
 expression. if (!isSafeAssign(parent, seenSideEffects)) {
if (isSafeAssign(this, child, parent, seenSideEffects)) {
if (isSafeAssignTo)
 of "foo()". else
 of "foo()" is not allowed in expressions:
 is safe. } else
if (isSafeAssign(parent, seenSideEffects, child, false)) {
if (isSafeAssignTo(parent)) { }
 means "foo()" for a simple expression,
 expression.
 of "foo()" else
 is unsafe.{
if (isExpression(parent, seenSideEffects)) {
if (isSafeAssign(parent, seenSideEffects, requiresDecompose)) {
 (=foo) {
 in expressions. if(isSafeAssign(parent, seenSideEffects)) {
if  applicable.
if (inline)
 like "foo"){
 (<foo)) {
if (isSafeAssign(parent, seenSideEffects) && parentType == 1) {
 of "foo()" is not allowed. The
if (isSafeAssign(parent, "foo()")
if  not allowed.
if (isSafeAssign(parent,  foo)))
if  not needed.
if (isSafeAssign(parent, seenSideEffects) ||!parent.x) {
 (foo(){
if (isSafeAssignTo(name)) { }
if (isSafeAssign(parent, seenSideEffects) && parentType == 0) {
if (isSafeAssign( parent, child)) { }
 of "foo()". } else
 is not safe. else
if (isSafeAssign(parent, seenSideEffects) || expressionRoot) {
if (isSafeAssign(parent, seenSideEffects) || isSimpleName) {
if  the expression is unsafe
 is allowed.
 is safe.{
 is unsafe.
if (isSafeAssign(parentType)) {
if (isSafeAssign(child, null, parent, seenSideEffects)) {
if (isSafeAssign(parent, seenSideEffects) || child == null) {
 is always safe. else
if (isSafeAssignTo())
if (isSafeAssign(parent, seenSideEffects) || parent!= child) {
if (isSafeAssign(child, child, parent, seenSideEffects)) {
if (isSafeAssign(childName)) {
 of "foo()" is allowed
 if (!parent, seenSideEffects)) {
. else if(isSafeAssign(parent, seenSideEffects)) {
if (case)
(abc) {
 of "foo()" is unsafe
if (isNode(parent, seenSideEffects)) {
if (isSafeAssign(child)) { }
 is not allowed. else
if (isSafeAssign(childName, seenSideEffects)) {
if (isSafeAssign(expressionRoot, seenSideEffects)) {
 of "foo()" is OK
 is OK.
if (isSafeAssign(parent, expressionRoot)) {
if (isSafeAssign(...))
if (isSafeAssign(parent, seenSideEffects) ||!inline) {
 is safe. } }
if (expression)
if (isSafeAssign(parentName, seenSideEffects)) {
 is safe. }
if (isSafeAssign(childNode)) {
if (isSafeAssign((parent, seenSideEffects)) {
 like foo{
if (isSafeAssign(parent)) { }
if (isSafeAssign(parent, seenSideEffects) ||!safe) {
... if(isSafeAssign(parent, seenSideEffects)) {
if (isSafeAssign(parent, seenSideEffects) && inlineCall) {
if (isSafeAssign(parent, namedExpression)) {
if (isSafeAssign(parent, seenSideEffects) && parentRoot) {
 is allowed. else
if (isSafeAssign(parent, seenSideEffects) || inlineCall) {
if (isSafeAssign(parentNode, parent, seenSideEffects)) {
if (isSafeAssign(parent, simplifiedName)) {
 node.
: foo{
if (isSafeAssign(parent, simpleNames)) {
if (isSafeAssign(parent, seenSideEffects) &&!escape) {
if (isSafeAssign(parent, node.x)) {
if (isSafeAssign(childNode, parent, seenSideEffects)) {
if (isSafeAssign(parent, seenSideEffects, parentRoot)) {
 expression: if(isSafeAssign(parent, seenSideEffects)) {
 is safe:
if (isSafeAssign(stringName)) {
. } if(isSafeAssign(parent, seenSideEffects)) {
if (isSafeAssign(parent, simpleNameString)) {
if (isSafeAssign(parent, simpleCase)) {
if (isSafeAssign(parent, seenSideEffects, expressionName)) {
if (isSafeAssign(parent, seenSideEffects) ||!escape) {
 if ((isSafeAssign(parent, seenSideEffects)) {
if (isSafeAssign(childType)) {
. else
if (isSafeAssign(parent, node.name)) {
 switch ((parent, seenSideEffects)) {
 like "{
. try{
if (isSafeAssign(parent, seenSideEffects, expressionNode)) {
if  it exists:
if  it exists!
if (check(parent, seenSideEffects)) {
if (isSafeAssign(parent) {
if (isSafeAssign(parent, seenSideEffects)))) {
if (isSafeAssign(name, parent, seenSideEffects)) {
if (isSafeAssign(Child, parent, seenSideEffects)) {
if (block(parent, seenSideEffects)) {
if (isSafeAssign(parent, seenSideEffects) {
 expression:
if (isSafeAssign(this, parent, seenSideEffects)) {
if (isSafeAssign(parent)))) {
if (safe(parent, seenSideEffects)) {
. }
 while (isSafeAssign(parent, seenSideEffects)) {
if (isSafeAssign(parent, seenSideEffects, child)) {
if (isSafeAssign(parent, seenSideEffects, 0)) {
if (isSafeAssign( node, seenSideEffects)) {
if (isSafeAssign(node)) {
...
if (isSafeAssign(parent, seenSideEffects, null)) {
:
if (isSafeAssign(parent, true)) {
if (isSafeAssign(parent, node)) {
